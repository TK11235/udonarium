<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>ダイスボットのつくりかた</title>
</head>
<body>
<h1>ダイスボットのつくりかた</h1>

<h2>■概要</h2>
ここでは「どどんとふ」のダイスボットを自作してみたい人用に具体的な手順について記述しています。<br/>
<br/>
<h2>■そもそもダイスボットって何？</h2>
「ダイス＋ロボット」でダイスボット。<br/>
元々はチャットソフトでダイスを振ってくれるロボットの用なツールを指す言葉ですね。<br/>
どどんとふではそのネーミングを引き継いでゲーム用のダイステキストを処理する機能を「ダイスボット」と呼んでいます。<br/>
<br/>
<h2>■ダイスボットの自作って？</h2>
どどんとふで遊ぼうと思ったゲームがダイスボットの一覧に無い。<br/>
そんな時にどうするか？<br/>
<br/>
作者に頼むのもモチロンいいですね。<br/>
<br/>
でも、超マイナールールだったり自作ＴＲＰＧだったり、あるいは単純にプログラミングってのが楽しそうだったり。<br/>
色んな理由で自分で作りたくなる時ってのはあるものです。<br/>
そんなダイスボットの自作が出来ちゃうのがどどんとふの魅力の一つ。<br/>
オープンソースの素晴らしさというわけですね。<br/>
<br/>
どどんとふのダイスボットは「Ruby」というプログラミング言語でソースコードを書くことで追加・変更することができます。<br/>
「うっはープログラミングとかサッパリだわー」という人は、流石にこの先は読まなくてもOKです。<br/>
「Ruby！いいね！俺大好きなんだよ！」なんて酔狂な方はもちろんウェルカム！<br/>
でも、どちらかというと「Rubyかー、この機会にちょっと勉強してみようかな？」という方向けに説明進めていきましょう。<br/>
<br/>
<h2>■環境の用意</h2>
それではWindows環境向けにダイスボットを自作するための手順を説明していきましょう。<br/>
＃Unix系OSの人なら当然Rubyはインストール済みと信じて説明は割愛。<br/>
ダイスボットの作成のためにはWindows用のRuby実行環境を作成する必要があります。<br/>
RubyInstallerから、「Ruby 1.9.X-pXXX」（Xは任意の数字）をダウンロードします。<br/>
<br/>
　<a href="http://rubyinstaller.org/">http://rubyinstaller.org/</a><br/>
<br/>
あとは、インストーラーの指示に従ってインストール。<br/>
そしてインストールディレクトリの bin にパスを通します。（パスを通す、の意味が知らない人はネットで検索だ！）<br/>
Ruby1.9.3のデフォルトだと「C:\Program Files\Ruby193\bin」ですかね。 ruby.exe のある場所にパスを通すのがポイントです。<br/>
後はコマンドプロンプト開いて（コマンドプロンプト、の意味が分からない人はネットで（略））、<br/>
ruby -v <br/>
とコマンドを実行して、Rubyのバージョン情報が表示されればOKです。<br/>
準備万端。それではダイスボットを作っていきましょう！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その１　名前大事！</h2>
今回サンプルとして作るダイスボット用に架空のゲームシステムがあるとしましょう。<br/>
<hr/>
タイトル：仮ダイス
<hr/>
・判定方法<br/>
　6面ダイスをX個振るシステム。<br/>
　判定コマンドは<br/>
　　KDx>=y（xはダイスロール数、yは目標値）<br/>
<hr/>
<br/>
これをダイスボットで実装する方法を考えて行きましょう。<br/>
<br/>
まずは　diceBot　ディレクトリを開きます。<br/>
どどんとふ なら　src_bcdice/diceBot<br/>
B＆C Dice2.0 なら　src/diceBot<br/>
その中に　_Template.rb　という名前のファイルがあります。<br/>
<br/>
テンプレート、TRPGでもよく使われる単語ですね。<br/>
要は「ひな型」って意味でして、それをもとに作れば1から作るよりも楽だよーってニュアンスですね。<br/>
ではでは、そのニュアンスを信じて　_Template.rb　ファイルを元に作ってみましょう。<br/>
_Template.rb　ファイルをコピーして、今回のゲーム用のタイトルをファイル名に付けましょう。<br/>
タイトルが「仮ダイス」ですから<br/>
<br/>
　KariDice.rb<br/>
<br/>
ですかね。<br/>
このKariDiceという名前は「ダイスボットの型名」と呼んで他でも使いますので「ファイル名なんてなんでもいいや」とか思わずにしっかり決めてくださいね。<br/>
プログラミングでは命名が何より大事ですので。<br/>
この KariDice.rb　を以降は編集していきます。<br/>
<br/>
<h2>■自作ダイスボットの作り方：その２　まずは形から</h2>
KariDice.rb はまだ中身は　_Template.rb　ファイルのままですね。<br/>
この中身をチョイチョイっと書き換えて仮ダイスを実装していきましょう。<br/>
ファイルを開いて、<br/>
<br/>
class Template < DiceBot<br/>
<br/>
ここを、今回のダイスボットは名前が 「KariDice」なので<br/>
<br/>
class KariDice < DiceBot<br/>
<br/>
と書き換え。ファイル名の（～.rb）部分と同じにするわけですね。<br/>
続いて<br/>
<pre><code>
  def gameName
    'ゲーム名'
  end
  
  def gameType
    "GameType"
  end
</code></pre>
を<br/>
<pre><code>
  def gameName
    '仮ダイス'
  end
  
  def gameType
    "KariDice"
  end
</code></pre>
に変更。<br/>
ゲームの日本語名とファイル名と同じ英文字での型名を定義しています。<br/>
では書き間違いがないか、念のため　KariDice.rb　の置いてあるディレクトリで<br/>
<br/>
　ruby -cw KariDice.rb<br/>
<br/>
とコマンドを実行しましょう。<br/>
<br/>
　Syntax OK<br/>
<br/>
と表示されれば問題ありません。<br/>
<br/>
エラーが表示される場合はそこに文法間違いがあるので確認しましょう。<br/>
もうこれだけでダイスボットとしての形は整ったことになります！<br/>
<br/>
試しにどどんとふで実際に動かしてみましょう。<br/>
どどんとふサーバ上の　src_bcdice/diceBot　に　KariDice.rb　を置いてログイン。<br/>
ダイスボット一覧の一番下に「仮ダイス」が表示されましたね。<br/>
いい感じです！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その３　テストファースト！</h2>
では、今回実装する予定の判定コマンドを実装していきましょう。<br/>
定義はこうでしたね。<br/>
<br/>
<hr/>
・判定方法<br/>
　6面ダイスをX個振るシステム。<br/>
　判定コマンドは<br/>
　　KDx>=y（xはダイスロール数、yは目標値）<br/>
<hr/>
<br/>
これを実装するには、<br/>
<pre><code>
  setPrefixes([])
</code></pre>
と<br/>
<pre><code>
  def rollDiceCommand(command)
    ''
  end
</code></pre>
の２つのメソッドを書き換えることになります。<br/>
引数の　command　にダイスボットとして入力した文字列が渡されますので、そこからロールの判定を行い、結果の文字列を戻り値に渡せばOKです。<br/>
では早速実装！<br/>
…とその前に、動作テストの用意をしましょう。<br/>
どどんとふのダイスボットは作成時に動作検証をしやすいように動作テスト用の仕組みが用意されています（ユニットテストと呼ばれるものですね）。<br/>
これを活用すればダイスボットが正しく動いているかをどどんとふ上で確認しなくてもよいのでとっても楽です。<br/>
どどんとふ なら　src_bcdice<br/>
B＆C Dice2.0 なら　src　に移動。<br/>
そこにある　test.rb　がテスト用のスクリプト。
そして test/data/　配下にあるテキストファイルが全てテスト用のデータです。<br/>
<br/>
ここでは例として　Cthulhu.txt　を開きましょう。<br/>
<br/>
<hr/>
============================<br/>
input:<br/>
1D100<=10<br/>
output:<br/>
Cthulhu : (1D100<=10) ＞ 98 ＞ 致命的失敗<br/>
rand:98/100<br/>
============================<br/>
input:<br/>
1D100<=10<br/>
output:<br/>
Cthulhu : (1D100<=10) ＞ 45 ＞ 失敗<br/>
rand:45/100<br/>
============================<br/>
<hr/>
<br/>
といった記述が並んでいますね。<br/>
テストデータの書式は<br/>
<br/>
<hr/>
input:
（テストしたいデータ）<br/>
output:<br/>
（ダイスボットの型名） : （出力される文字列）<br/>
rand:（テストしたいダイスの出目）<br/>
<hr/>
<br/>
となります。<br/>
また、複数テストデータを記述するときは、データの間を<br/>
============================<br/>
で区切る必要があります。<br/>
<br/>
output の「（ダイスボットの型名）：」はダイスボットの内部で自動的に生成されるので常に必要です。<br/>
実際に表示される文字を意識したいので、省略はできなくなっています。<br/>
rand の記述は　1/6,2/6　のように　（出目）/（ロールするダイス）　の形で記述します。<br/>
これを使えば3D6で1,1,1を出すようなパターンでも　1/6,1/6,1/6 と記述してしまえばすぐ検証できるわけですね。便利！<br/>
<br/>
今回のテストとして新しいテストデータとして KariDice.txt　ファイルを作成しましょう。<br/>
 .rb と同じ名前でテストデータの .txt を作成するわけですね。<br/>
<br/>
<hr/>
input:<br/>
KD3>=10<br/>
output:<br/>
KariDice : (KD3>=10) ＞ 10[2,5,3] ＞ 成功<br/>
rand:2/6,5/6,3/6<br/>
============================<br/>
input:<br/>
KD3>=10<br/>
output:<br/>
KariDice : (KD3>=10) ＞ 9[1,5,3] ＞ 失敗<br/>
rand:1/6,5/6,3/6<br/>
<hr/>
<br/>
そしてテストの実行。<br/>
<br/>
ruby test.rb KariDice<br/>
<br/>
とコマンドを実行。<br/>
<br/>
<hr/>
<pre><code>ruby test.rb KariDice
XX

[Failures]
Game type: KariDice
Index: 1
Input:
  KD3>=10
Expected:
  KariDice : (KD3>=10) ＞ 10[2,5,3] ＞ 成功
Result:
  ダイス残り：2/6, 5/6, 3/6
Rands: 2/6, 5/6, 3/6
===========================
Game type: KariDice
Index: 2
Input:
  KD3>=10
Expected:
  KariDice : (KD3>=10) ＞ 9[1,5,3] ＞ 失敗
Result:
  ダイス残り：1/6, 5/6, 3/6
Rands: 1/6, 5/6, 3/6
</code></pre>
<hr/>
<br/>
と出力されます。<br/>
<br/>
これは「xx」とｘが２つなので「テスト2件に失敗」を示します。成功なら「..」となって、「OK」が表示されます。<br/>
ここでは判定成功時と失敗時の2件の動作を確認して、両方に失敗したということですね。<br/>
早く「OK」が表示されるのが楽しみですね！<br/>
<br/>
以後はソースコードを変更したらテストを実行して動作を確認、<br/>
新しい実装をする時には先にですとデータを作って、動作確認、を繰り返すことになります。<br/>
テスト→実装→テスト→実装…の順ですね。<br/>
<br/>
ちなみ、こうやって先にテストを作ってからプログラムを作成する方法をテストファーストって呼んだりします。<br/>
是非実績していきましょう！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その４　そして実装</h2>
準備もできたので、ダイスボットの実装を。<br/>
<br/>
まずはコマンドの定義を<br/>
<pre><code>
  setPrefixes(['KD\d+>=\d+'])
</code></pre>
ここに書いて、どどんとふにコマンドを教えてやる必要があります。忘れがちなので注意！<br/>
ポイントは、文字列を””ではなく’’で囲むことですね。<br/>
こうしないと￥ｄのｄが￥文字でエスケープされてしまい、「￥ｄ」という文字にならないのですね。<br/>
正規表現相当の文字をここで文字列として定義してRubyとActionScript両方で使っているので、扱いにクセがあります。<br/>
分かりにくい場合は、今後の拡張性も考えて<br/>
</code></pre>
  setPrefixes(['KD.*'])<br/>
</code></pre>
みたいに手を抜いた記述にしてしまうのも手です。<br/>
とりあえず動かしてみたいですしね。<br/>
次にコマンドの判定部分を実装。<br/>
<pre><code>
  def rollDiceCommand(command)
    debug("rollDiceCommand Begin")
    
    return '' unless( /^KD(\d+)>=(\d+)$/ =~ command )
    
    debug("command", command)
    
    diceCount = $1.to_i
    target = $2.to_i
    
    total, diceText, = roll(diceCount, 6)
    result = (total >= target ? "成功" : "失敗")
    
    text = "(#{command}) ＞ #{total}[#{diceText}] ＞ #{result}"
    debug("rollDiceCommand result")
    
    return text
  end
</code></pre>
これで成否判定は実装完了。<br/>
rollメソッドはDiceBotクラスで実装済みのメソッドで、<br/>
    合計, ダイスの文字列, [その他のデータ] = roll(ダイス数, ダイス種別)<br/>
みたいに使います。今回は[その他のデータ]は使わないので省略して<br/>
　合計, ダイスの文字列, ＝<br/>
となっています。　＝　の直前に「,」があるのがポイントです。<br/>
この書き方で[その他のデータ]は無視するよーって宣言しているわけですね。<br/>
あと、<br/>
<pre><code>
　debug("rollDiceCommand Begin")
</code></pre>
と書いている箇所はデバッグ用の文字列です。<br/>
さっきテストを実行したときに<br/>
<br/>
<hr/>
Index: 1<br/>
<hr/>
<br/>
みたいな表示がありましたが、ここにあるIndexというのはテストの通番でして、<br/>
<br/>
　ruby test.rb KariDice 1<br/>
<br/>
のようにテスト時にダイスボット名と共にインデックス番号を指定すると、そのテスト１件だけを実行してくれます。<br/>
特定のテストを詳細に検証する時に使うわけですが、その際にはデバッグ文が出力されるようになります。<br/>
<br/>
たとえば、<br/>
<br/>
　debug("command", command)<br/>
<br/>
と書くと<br/>
<br/>
　command : "KD3>=10"<br/>
<br/>
みたいにデバッグ文が出力されるので読みやすく検証に便利です。<br/>
つまりテストでは<br/>
<br/>
　ruby test.rb （ダイスボット名）<br/>
<br/>
で全体を確認しつつ、失敗パターンをピックアップ確認したいときは<br/>
<br/>
　ruby test.rb （ダイスボット名） （インデックス番号）<br/>
<br/>
で実行。これがテストの王道ということですね。<br/>
<br/>
あ、ちなみに<br/>
<br/>
　ruby test.rb<br/>
<br/>
だけなら全ダイスボットのテストが実行されます。<br/>
最後の最後に試しておくと、他に影響与えてないことが確認できて安心です。<br/>
<br/>
さてさて、では先ほど提示した内容を実装してテストしてみましょう。<br/>
<br/>
<hr/>
ruby test.rb KariDice<br/>
..<br/>
OK.<br/>
<hr/>
<br/>
「OK」が表示されました！やったね！！<br/>
<br/>
<br/>
<h2>■自作ではなく、拡張する場合の注意点</h2>
ダイスボットを自作するのではなく、既存のダイスボットを拡張する、という方も多いでしょう。<br/>
その場合も、基本的には同じ手順で大丈夫です。<br/>
ただ、１点だけ注意点となるのが「後方互換性」について。<br/>
<br/>
「どどんとふ」では過去のバージョンとの互換性を何よりも重視しています。<br/>
オンセ用に作った自キャラ用のダイスボットのコマンドがある日急に使えなくなる、というのは最も避けたい事態ですね。<br/>
なので、コマンドや機能を拡張する場合には既存の機能を変更しないのが大事です。<br/>
つまり「後方互換性」ですね。<br/>
<br/>
もちろん、オリジナルのダイスボットを作る場合や、個人的に拡張する場合には自由に作ってOKですが、<br/>
完成したら公式にも送ろう…なんて素晴らしいことを考えている方は注意していただければと思います。<br/>
<br/>
<br/>
<h2>■終わりに</h2>
ここまでできれば後は同じことを繰り返してダイスボットの実装ができます。<br/>
<br/>
まとめると<br/>
<br/>
　テストファーストでテスト作成し失敗することを確認。<br/>
　→コードを実装、テスト。<br/>
　→うまく動かなかったらインデックス指定しデバッグ表示で内容確認。<br/>
　→OKが表示されたら祝杯！<br/>
<br/>
こんな感じですね。<br/>
<br/>
テストデータの作成にはパターンの網羅や以上・以下の閾値確認など色々ポイントがあるんですが、<br/>
それ書き出すとまた長文になりそうなので各自で工夫してみてくださいね。<br/>
<br/>
ではでは！<br/>
<br/>
<br/>
<hr/>
<br/>
<h2 id="aboutTestChanged">■追記：テスト方式の変更について。</h2>
B&CVer2.02.27、どどんとふVer.1.46.07 以降ではテストの方式に変更があります。<br>
ここでは、過去のバージョンでテストを行っていた人用に差分について説明します。<br/>
<br/>
◆テストデータの設置場所<br/>
・これまで：<br/>
test/testData.txt に各ゲーム種別のテストを追加。<br/>
・これから：<br/>
data/(各ゲーム種別名).txt に各ゲームのテストを追加。<br/>
→ テストデータをゲーム毎に分割。<br/>
<br/>
◆テストの記述方法<br/>
・これまで：
<pre><code>============================
input:1D100<=10	Cthulhu
output:
Cthulhu : (1D100<=10) ＞ 45 ＞ 失敗
rand:45/100
============================
</code></pre>
・これから：
<pre><code>============================
input:
1D100<=10
output:
Cthulhu : (1D100<=10) ＞ 45 ＞ 失敗
rand:45/100
============================
</code></pre>
→ テストデータにゲームの記述は不要に。<br/>
　inputはoutputと同様に改行後に記述に。<br/>
<br/>
◆テストの実行方法<br/>
　全テスト実施、ゲーム毎の一括実施は同様。異なるのは特定のテストだけを実施する場合。<br/>
・これまで：<br/>
ruby test.rb 1<br/>
・これから：<br/>
ruby test.rb Cthulhu 1<br/>
→ゲーム種別を明示したうえで、実行するテスト番号を追記する必要があります。<br/>
<br/>
以上！<br/>
<br/>
</body>
</html>
