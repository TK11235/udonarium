/* Generated by Opal 1.0.3 */
Opal.modules["utils/table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$match', '$raise', '$to_i', '$[]', '$roll', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Table');

    var $nesting = [self].concat($parent_nesting), $Table_initialize$1, $Table_roll$2;

    self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
    
    
    Opal.def(self, '$initialize', $Table_initialize$1 = function $$initialize(name, type, items) {
      var self = this, m = nil;

      
      self.name = name;
      self.items = items.$freeze();
      m = /(\d+)D(\d+)/i.$match(type);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + (type))
      };
      self.times = m['$[]'](1).$to_i();
      return (self.sides = m['$[]'](2).$to_i());
    }, $Table_initialize$1.$$arity = 3);
    return (Opal.def(self, '$roll', $Table_roll$2 = function $$roll(bcdice) {
      var $a, $b, self = this, value = nil, index = nil;

      
      $b = bcdice.$roll(self.times, self.sides), $a = Opal.to_ary($b), (value = ($a[0] == null ? nil : $a[0])), $b;
      index = $rb_minus(value, self.times);
      return "" + (self.name) + "(" + (value) + ") ＞ " + (self.items['$[]'](index));
    }, $Table_roll$2.$$arity = 1), nil) && 'roll';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/range_table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$alias_method', '$freeze', '$lambda', '$name', '$sum', '$content', '$attr_reader', '$match', '$raise', '$to_i', '$[]', '$store', '$find', '$include?', '$range', '$roll', '$map', '$split', '$to_proc', '$fetch', '$formatted=', '$-', '$private', '$coerce_to_int_range', '$sort_by', '$min', '$assert_min_sum_is_covered', '$assert_max_sum_is_covered', '$assert_no_gap_or_overlap_in_ranges', '$===', '$is_a?', '$begin', '$end', '$class', '$first', '$*', '$last', '$each_cons', '$max', '$+']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeTable');

    var $nesting = [self].concat($parent_nesting), $RangeTable$1, $RangeTable$2, $RangeTable_initialize$3, $RangeTable_fetch$4, $RangeTable_roll$6, $RangeTable_store$7, $RangeTable_coerce_to_int_range$11, $RangeTable_assert_min_sum_is_covered$12, $RangeTable_assert_max_sum_is_covered$13, $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

    self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
    
    Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], ($RangeTable$1 = function(){var self = $RangeTable$1.$$s || this;

    return self.$alias_method("to_s", "formatted")}, $RangeTable$1.$$s = self, $RangeTable$1.$$arity = 0, $RangeTable$1)));
    Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
    Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
    Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($RangeTable$2 = function(table, result){var self = $RangeTable$2.$$s || this;

    
      
      if (table == null) {
        table = nil;
      };
      
      if (result == null) {
        result = nil;
      };
      return "" + (table.$name()) + "(" + (result.$sum()) + ") ＞ " + (result.$content());}, $RangeTable$2.$$s = self, $RangeTable$2.$$arity = 2, $RangeTable$2)));
    self.$attr_reader("name");
    self.$attr_reader("num_of_dice");
    self.$attr_reader("num_of_sides");
    
    Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
      var $iter = $RangeTable_initialize$3.$$p, formatter = $iter || nil, $a, self = this, m = nil;

      if ($iter) $RangeTable_initialize$3.$$p = null;
      
      
      if ($iter) $RangeTable_initialize$3.$$p = null;;
      self.name = name.$freeze();
      self.formatter = ($truthy($a = formatter) ? $a : $$($nesting, 'DEFAULT_FORMATTER'));
      m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (self.name) + ": invalid dice roll method: " + (dice_roll_method))
      };
      self.num_of_dice = m['$[]'](1).$to_i();
      self.num_of_sides = m['$[]'](2).$to_i();
      return self.$store(items);
    }, $RangeTable_initialize$3.$$arity = 3);
    
    Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
      var $$5, self = this, item = nil;

      
      item = $send(self.items, 'find', [], ($$5 = function(i){var self = $$5.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i.$range()['$include?'](value);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
      if ($truthy(item)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": value is out of range: " + (value))
      };
      return item;
    }, $RangeTable_fetch$4.$$arity = 1);
    
    Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(bcdice) {
      var $a, $b, self = this, sum = nil, values_str = nil, values = nil, result = nil, $writer = nil;

      
      $b = bcdice.$roll(self.num_of_dice, self.num_of_sides), $a = Opal.to_ary($b), (sum = ($a[0] == null ? nil : $a[0])), (values_str = ($a[1] == null ? nil : $a[1])), $b;
      values = $send(values_str.$split(","), 'map', [], "to_i".$to_proc());
      result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
      
      $writer = [self.formatter['$[]'](self, result)];
      $send(result, 'formatted=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return result;
    }, $RangeTable_roll$6.$$arity = 1);
    self.$private();
    
    Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
      var $$8, $$9, $$10, self = this, items_with_range = nil, sorted_items = nil;

      
      items_with_range = $send(items, 'map', [], ($$8 = function(r, c){var self = $$8.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (c == null) {
          c = nil;
        };
        return [self.$coerce_to_int_range(r), c];}, $$8.$$s = self, $$8.$$arity = 2, $$8));
      sorted_items = $send(items_with_range, 'sort_by', [], ($$9 = function(r, _){var self = $$9.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return r.$min();}, $$9.$$s = self, $$9.$$arity = 2, $$9));
      self.$assert_min_sum_is_covered(sorted_items);
      self.$assert_max_sum_is_covered(sorted_items);
      self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
      self.items = $send(sorted_items, 'map', [], ($$10 = function(range, content){var self = $$10.$$s || this;

      
        
        if (range == null) {
          range = nil;
        };
        
        if (content == null) {
          content = nil;
        };
        return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();}, $$10.$$s = self, $$10.$$arity = 2, $$10)).$freeze();
      return self;
    }, $RangeTable_store$7.$$arity = 1);
    
    Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
      var $a, self = this, $case = nil;

      
      $case = x;
      if ($$($nesting, 'Integer')['$===']($case)) {return $$($nesting, 'Range').$new(x, x)}
      else if ($$($nesting, 'Range')['$===']($case)) {if ($truthy(($truthy($a = x.$begin()['$is_a?']($$($nesting, 'Integer'))) ? x.$end()['$is_a?']($$($nesting, 'Integer')) : $a))) {
        return x}};
      return self.$raise($$($nesting, 'TypeError'), "" + (self.name) + ": " + (x) + " (" + (x.$class()) + ") must be an Integer or a Range with Integers ");
    }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
    
    Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
      var self = this, min_sum = nil, range = nil;

      
      min_sum = self.num_of_dice;
      range = sorted_items.$first()['$[]'](0);
      if ($truthy(range['$include?'](min_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": min value (" + (min_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
    
    Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
      var self = this, max_sum = nil, range = nil;

      
      max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
      range = sorted_items.$last()['$[]'](0);
      if ($truthy(range['$include?'](max_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": max value (" + (max_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
    return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
      var $$15, self = this;

      
      $send(sorted_items, 'each_cons', [2], ($$15 = function(i1, i2){var self = $$15.$$s || this, r1 = nil, r2 = nil, max1 = nil, next_of_max1 = nil;
        if (self.name == null) self.name = nil;

      
        
        if (i1 == null) {
          i1 = nil;
        };
        
        if (i2 == null) {
          i2 = nil;
        };
        r1 = i1['$[]'](0);
        r2 = i2['$[]'](0);
        max1 = r1.$max();
        next_of_max1 = $rb_plus(max1, 1);
        if ($truthy(r2['$include?'](max1))) {
          self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range overlap: " + (r1) + " and " + (r2))};
        if ($truthy(r2['$include?'](next_of_max1))) {
          return nil
        } else {
          return self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range gap: " + (r1) + " and " + (r2))
        };}, $$15.$$s = self, $$15.$$arity = 2, $$15));
      return self;
    }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $gvars = Opal.gvars, $range = Opal.range;

  Opal.add_stubs(['$require', '$setPrefixes', '$sub', '$roll_tables', '$===', '$to_i', '$last_match', '$debug', '$getCheckDieResult', '$lambda', '$getXrmDamage', '$getHitResult', '$key?', '$raise', '$[]', '$roll', '$bcdice', '$start_with?', '$content', '$*', '$sum', '$match', '$getBaseValue', '$times', '$getHitText', '$+', '$getDamages', '$<<', '$join', '$>=', '$length', '$>', '$getTotalDamage', '$nil?', '$parren_killer', '$call', '$ceil', '$/', '$getDamageInfo', '$getHitResultOne', '$[]=', '$-', '$empty?', '$to_s', '$each', '$delete', '$inject', '$size', '$inspect', '$critical_hit_may_occur', '$name', '$push', '$get_table_by_number', '$freeze', '$new']);
  
  self.$require("utils/table");
  self.$require("utils/range_table");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BattleTech');

    var $nesting = [self].concat($parent_nesting), $BattleTech_changeText$1, $BattleTech_rollDiceCommand$2, $BattleTech_getXrmDamage$5, $BattleTech_getHitResult$6, $BattleTech_getBaseValue$8, $BattleTech_getHitText$9, $BattleTech_getDamages$10, $BattleTech_getDamageInfo$12, $BattleTech_getTotalDamage$13, $BattleTech_getHitResultOne$16, $BattleTech_getCheckDieResult$17;

    
    Opal.const_set($nesting[0], 'ID', "BattleTech");
    Opal.const_set($nesting[0], 'NAME', "バトルテック");
    Opal.const_set($nesting[0], 'SORT_KEY', "はとるてつく");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・判定方法\n" + "　(回数)BT(ダメージ)(部位)+(基本値)>=(目標値)\n" + "　回数は省略時 1固定。\n" + "　部位はC（正面）R（右）、L（左）。省略時はC（正面）固定\n" + "　U（上半身）、L（下半身）を組み合わせ CU/RU/LU/CL/RL/LLも指定可能\n" + "　例）BT3+2>=4\n" + "　　正面からダメージ3の攻撃を技能ベース2目標値4で1回判定\n" + "　例）2BT3RL+5>=8\n" + "　　右下半身にダメージ3の攻撃を技能ベース5目標値8で2回判定\n" + "　ミサイルによるダメージは BT(ダメージ)の変わりに SRM2/4/6, LRM5/10/15/20を指定\n" + "　例）3SRM6LU+5>=8\n" + "　　左上半身にSRM6連を技能ベース5目標値8で3回判定\n" + "・CT：致命的命中表\n" + "・DW：転倒後の向き表\n" + "・CDx：メック戦士意識維持表。ダメージ値xで判定　例）CD3\n");
    self.$setPrefixes(["\\d*SRM\\d+.+", "\\d*LRM\\d+.+", "\\d*BT.+", "CT", "DW", "CD\\d+"]);
    Opal.const_set($nesting[0], 'NO_CRITICAL_HIT_LIMIT', 7);
    
    Opal.def(self, '$changeText', $BattleTech_changeText$1 = function $$changeText(string) {
      var self = this;

      return string.$sub(/PPC/, "BT10")
    }, $BattleTech_changeText$1.$$arity = 1);
    
    Opal.def(self, '$rollDiceCommand', $BattleTech_rollDiceCommand$2 = function $$rollDiceCommand(command) {
      var $$3, $$4, self = this, result = nil, count = nil, $case = nil, damage = nil, tail = nil, type = nil, damageFunc = nil, damageValue = nil;

      
      result = self.$roll_tables(command, $$($nesting, 'TABLES'));
      if ($truthy(result)) {
        return result};
      count = 1;
      if ($truthy(/^(\d+)(.+)/['$==='](command))) {
        
        count = $$($nesting, 'Regexp').$last_match(1).$to_i();
        command = $$($nesting, 'Regexp').$last_match(2);};
      self.$debug("executeCommandCatched count", count);
      self.$debug("executeCommandCatched command", command);
      $case = command;
      if (/^CD(\d+)$/['$===']($case)) {
      damage = $$($nesting, 'Regexp').$last_match(1).$to_i();
      return self.$getCheckDieResult(damage);}
      else if (/^((S|L)RM\d+)(.+)/['$===']($case)) {
      tail = $$($nesting, 'Regexp').$last_match(3);
      type = $$($nesting, 'Regexp').$last_match(1);
      damageFunc = $send(self, 'lambda', [], ($$3 = function(){var self = $$3.$$s || this;

      return self.$getXrmDamage(type)}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      return self.$getHitResult(count, damageFunc, tail);}
      else if (/^BT(\d+)(.+)/['$===']($case)) {
      self.$debug("BT pattern");
      tail = $$($nesting, 'Regexp').$last_match(2);
      damageValue = $$($nesting, 'Regexp').$last_match(1).$to_i();
      damageFunc = $send(self, 'lambda', [], ($$4 = function(){var self = $$4.$$s || this;

      return damageValue}, $$4.$$s = self, $$4.$$arity = 0, $$4));
      return self.$getHitResult(count, damageFunc, tail);};
      return nil;
    }, $BattleTech_rollDiceCommand$2.$$arity = 1);
    
    Opal.def(self, '$getXrmDamage', $BattleTech_getXrmDamage$5 = function $$getXrmDamage(type) {
      var self = this, table = nil, roll_result = nil, lrm = nil, damage = nil, modified_damage = nil;

      
      if ($truthy($$($nesting, 'XRM_DAMAGE_TABLES')['$key?'](type))) {
      } else {
        self.$raise("" + "unknown XRM type:" + (type))
      };
      table = $$($nesting, 'XRM_DAMAGE_TABLES')['$[]'](type);
      roll_result = table.$roll(self.$bcdice());
      lrm = type['$start_with?']("L");
      damage = roll_result.$content();
      modified_damage = (function() {if ($truthy(lrm)) {
        return damage
      } else {
        
        return $rb_times(2, damage);
      }; return nil; })();
      return [modified_damage, roll_result.$sum(), lrm];
    }, $BattleTech_getXrmDamage$5.$$arity = 1);
    Opal.const_set($nesting[0], 'LRM_LIMIT', 5);
    
    Opal.def(self, '$getHitResult', $BattleTech_getHitResult$6 = function $$getHitResult(count, damageFunc, tail) {
      var $a, $$7, self = this, m = nil, side = nil, baseString = nil, target = nil, base = nil, partTable = nil, resultTexts = nil, damages = nil, hitCount = nil, totalResultText = nil;
      if ($gvars.SEND_STR_MAX == null) $gvars.SEND_STR_MAX = nil;

      
      m = /([LCR][LU]?)?(\+\d+)?>=(\d+)/.$match(tail);
      if ($truthy(m)) {
      } else {
        return nil
      };
      side = ($truthy($a = m['$[]'](1)) ? $a : "C");
      baseString = m['$[]'](2);
      target = m['$[]'](3).$to_i();
      base = self.$getBaseValue(baseString);
      self.$debug("side, base, target", side, base, target);
      partTable = $$$($$($nesting, 'HitPart'), 'TABLES')['$[]'](side);
      resultTexts = [];
      damages = $hash2([], {});
      hitCount = 0;
      $send(count, 'times', [], ($$7 = function(){var self = $$7.$$s || this, $b, $c, isHit = nil, hitResult = nil, damageText = nil;

      
        $c = self.$getHitText(base, target), $b = Opal.to_ary($c), (isHit = ($b[0] == null ? nil : $b[0])), (hitResult = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(isHit)) {
          
          hitCount = $rb_plus(hitCount, 1);
          $c = self.$getDamages(damageFunc, partTable, damages), $b = Opal.to_ary($c), (damages = ($b[0] == null ? nil : $b[0])), (damageText = ($b[1] == null ? nil : $b[1])), $c;
          hitResult = $rb_plus(hitResult, damageText);};
        return resultTexts['$<<'](hitResult);}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      totalResultText = resultTexts.$join("\n");
      if ($truthy($rb_ge(totalResultText.$length(), $gvars.SEND_STR_MAX))) {
        totalResultText = "..."};
      totalResultText = $rb_plus(totalResultText, "" + "\n ＞ " + (hitCount) + "回命中");
      if ($truthy($rb_gt(hitCount, 0))) {
        totalResultText = $rb_plus(totalResultText, $rb_plus(" 命中箇所：", self.$getTotalDamage(damages)))};
      return totalResultText;
    }, $BattleTech_getHitResult$6.$$arity = 3);
    
    Opal.def(self, '$getBaseValue', $BattleTech_getBaseValue$8 = function $$getBaseValue(baseString) {
      var self = this, base = nil;

      
      base = 0;
      if ($truthy(baseString['$nil?']())) {
        return base};
      base = self.$parren_killer($rb_plus($rb_plus("(", baseString), ")")).$to_i();
      return base;
    }, $BattleTech_getBaseValue$8.$$arity = 1);
    
    Opal.def(self, '$getHitText', $BattleTech_getHitText$9 = function $$getHitText(base, target) {
      var $a, $b, self = this, dice1 = nil, dice2 = nil, total = nil, isHit = nil, baseString = nil, result = nil;

      
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice1 = ($a[0] == null ? nil : $a[0])), $b;
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice2 = ($a[0] == null ? nil : $a[0])), $b;
      total = $rb_plus($rb_plus(dice1, dice2), base);
      isHit = $rb_ge(total, target);
      baseString = (function() {if ($truthy($rb_gt(base, 0))) {
        return "" + "+" + (base)
      } else {
        return ""
      }; return nil; })();
      result = "" + (total) + "[" + (dice1) + "," + (dice2) + (baseString) + "]>=" + (target) + " ＞ ";
      if ($truthy(isHit)) {
        result = $rb_plus(result, "命中 ＞ ")
      } else {
        result = $rb_plus(result, "外れ")
      };
      return [isHit, result];
    }, $BattleTech_getHitText$9.$$arity = 2);
    
    Opal.def(self, '$getDamages', $BattleTech_getDamages$10 = function $$getDamages(damageFunc, partTable, damages) {
      var $a, $b, $$11, self = this, resultText = nil, damage = nil, dice = nil, isLrm = nil, damagePartCount = nil;

      
      resultText = "";
      $b = damageFunc.$call(), $a = Opal.to_ary($b), (damage = ($a[0] == null ? nil : $a[0])), (dice = ($a[1] == null ? nil : $a[1])), (isLrm = ($a[2] == null ? nil : $a[2])), $b;
      damagePartCount = 1;
      if ($truthy(isLrm)) {
        
        damagePartCount = $rb_divide($rb_times(1.0, damage), $$($nesting, 'LRM_LIMIT')).$ceil();
        resultText = $rb_plus(resultText, "" + "[" + (dice) + "] " + (damage) + "点");};
      $send(damagePartCount, 'times', [], ($$11 = function(damageIndex){var self = $$11.$$s || this, $c, $d, currentDamage = nil, damageText = nil, text = nil, part = nil, criticalText = nil, $writer = nil;

      
        
        if (damageIndex == null) {
          damageIndex = nil;
        };
        $d = self.$getDamageInfo(dice, damage, isLrm, damageIndex), $c = Opal.to_ary($d), (currentDamage = ($c[0] == null ? nil : $c[0])), (damageText = ($c[1] == null ? nil : $c[1])), $d;
        $d = self.$getHitResultOne(damageText, partTable), $c = Opal.to_ary($d), (text = ($c[0] == null ? nil : $c[0])), (part = ($c[1] == null ? nil : $c[1])), (criticalText = ($c[2] == null ? nil : $c[2])), $d;
        if ($truthy(isLrm)) {
          resultText = $rb_plus(resultText, " ")};
        resultText = $rb_plus(resultText, text);
        if ($truthy(damages['$[]'](part)['$nil?']())) {
          
          $writer = [part, $hash2(["partDamages", "criticals"], {"partDamages": [], "criticals": []})];
          $send(damages, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        damages['$[]'](part)['$[]']("partDamages")['$<<'](currentDamage);
        if ($truthy(criticalText['$empty?']())) {
          return nil
        } else {
          return damages['$[]'](part)['$[]']("criticals")['$<<'](criticalText)
        };}, $$11.$$s = self, $$11.$$arity = 1, $$11));
      return [damages, resultText];
    }, $BattleTech_getDamages$10.$$arity = 3);
    
    Opal.def(self, '$getDamageInfo', $BattleTech_getDamageInfo$12 = function $$getDamageInfo(dice, damage, isLrm, index) {
      var self = this, currentDamage = nil;

      
      if ($truthy(dice['$nil?']())) {
        return [damage, damage.$to_s()]};
      if ($truthy(isLrm)) {
      } else {
        return [damage, "" + "[" + (dice) + "] " + (damage)]
      };
      currentDamage = $rb_minus(damage, $rb_times($$($nesting, 'LRM_LIMIT'), index));
      if ($truthy($rb_gt(currentDamage, $$($nesting, 'LRM_LIMIT')))) {
        currentDamage = $$($nesting, 'LRM_LIMIT')};
      return [currentDamage, currentDamage.$to_s()];
    }, $BattleTech_getDamageInfo$12.$$arity = 4);
    
    Opal.def(self, '$getTotalDamage', $BattleTech_getTotalDamage$13 = function $$getTotalDamage(damages) {
      var $$14, self = this, parts = nil, allDamage = nil, damageTexts = nil, result = nil;

      
      parts = ["頭", "胴中央", "右胴", "左胴", "右脚", "左脚", "右腕", "左腕"];
      allDamage = 0;
      damageTexts = [];
      $send(parts, 'each', [], ($$14 = function(part){var self = $$14.$$s || this, $$15, damageInfo = nil, damage = nil, damageCount = nil, criticals = nil, text = nil;

      
        
        if (part == null) {
          part = nil;
        };
        damageInfo = damages.$delete(part);
        if ($truthy(damageInfo['$nil?']())) {
          return nil;};
        damage = $send(damageInfo['$[]']("partDamages"), 'inject', [0], ($$15 = function(sum, i){var self = $$15.$$s || this;

        
          
          if (sum == null) {
            sum = nil;
          };
          
          if (i == null) {
            i = nil;
          };
          return $rb_plus(sum, i);}, $$15.$$s = self, $$15.$$arity = 2, $$15));
        allDamage = $rb_plus(allDamage, damage);
        damageCount = damageInfo['$[]']("partDamages").$size();
        criticals = damageInfo['$[]']("criticals");
        text = "";
        text = $rb_plus(text, "" + (part) + "(" + (damageCount) + "回) " + (damage) + "点");
        if ($truthy(criticals['$empty?']())) {
        } else {
          text = $rb_plus(text, "" + " " + (criticals.$join(" ")))
        };
        return damageTexts['$<<'](text);}, $$14.$$s = self, $$14.$$arity = 1, $$14));
      if ($truthy(damages['$empty?']())) {
      } else {
        self.$raise("" + "damages rest!! " + (damages.$inspect()))
      };
      result = damageTexts.$join(" ／ ");
      result = $rb_plus(result, "" + " ＞ 合計ダメージ " + (allDamage) + "点");
      return result;
    }, $BattleTech_getTotalDamage$13.$$arity = 1);
    
    Opal.def(self, '$getHitResultOne', $BattleTech_getHitResultOne$16 = function $$getHitResultOne(damage_text, hit_part_table) {
      var self = this, hit_part_roll_result = nil, hit_part = nil, critical_hit_may_occur_str = nil, result_parts = nil, critical_hit_occurred = nil, criticalText = nil, ct_roll_result = nil;

      
      hit_part_roll_result = hit_part_table.$roll(self.$bcdice());
      hit_part = hit_part_roll_result.$content();
      critical_hit_may_occur_str = (function() {if ($truthy(hit_part.$critical_hit_may_occur())) {
        return "（致命的命中）"
      } else {
        return ""
      }; return nil; })();
      result_parts = [["" + "[" + (hit_part_roll_result.$sum()) + "]", "" + (hit_part.$name()) + (critical_hit_may_occur_str), "" + (damage_text) + "点"].$join(" ")];
      critical_hit_occurred = false;
      criticalText = "";
      if ($truthy(hit_part.$critical_hit_may_occur())) {
        
        ct_roll_result = $$($nesting, 'TABLES')['$[]']("CT").$roll(self.$bcdice());
        critical_hit_occurred = $rb_gt(ct_roll_result.$sum(), $$($nesting, 'NO_CRITICAL_HIT_LIMIT'));
        if ($truthy(critical_hit_occurred)) {
          criticalText = ct_roll_result.$content()};
        result_parts.$push("" + "[" + (ct_roll_result.$sum()) + "] " + (ct_roll_result.$content()));};
      return [result_parts.$join(" ＞ "), hit_part.$name(), criticalText];
    }, $BattleTech_getHitResultOne$16.$$arity = 2);
    
    Opal.def(self, '$getCheckDieResult', $BattleTech_getCheckDieResult$17 = function $$getCheckDieResult(damage) {
      var $a, $b, self = this, table = nil, target = nil, dice1 = nil, dice2 = nil, total = nil, result = nil, text = nil;

      
      if ($truthy($rb_ge(damage, 6))) {
        return "死亡"};
      table = [[1, 3], [2, 5], [3, 7], [4, 10], [5, 11]];
      target = self.$get_table_by_number(damage, table, nil);
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice1 = ($a[0] == null ? nil : $a[0])), $b;
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice2 = ($a[0] == null ? nil : $a[0])), $b;
      total = $rb_plus(dice1, dice2);
      result = (function() {if ($truthy($rb_ge(total, target))) {
        return "成功"
      } else {
        return "失敗"
      }; return nil; })();
      text = "" + (total) + "[" + (dice1) + "," + (dice2) + "]>=" + (target) + " ＞ " + (result);
      return text;
    }, $BattleTech_getCheckDieResult$17.$$arity = 1);
    Opal.const_set($nesting[0], 'TABLES', $hash2(["CT", "DW"], {"CT": $$($nesting, 'RangeTable').$new("致命的命中表", "2D6", [[Opal.Range.$new(2, $$($nesting, 'NO_CRITICAL_HIT_LIMIT'), false), "致命的命中はなかった"], [$range(8, 9, false), "1箇所の致命的命中"], [$range(10, 11, false), "2箇所の致命的命中"], [12, "その部位が吹き飛ぶ（腕、脚、頭）または3箇所の致命的命中（胴）"]]), "DW": $$($nesting, 'Table').$new("転倒後の向き表", "1D6", ["同じ（前面から転倒） 正面／背面", "1ヘクスサイド右（側面から転倒） 右側面", "2ヘクスサイド右（側面から転倒） 右側面", "180度逆（背面から転倒） 正面／背面", "2ヘクスサイド左（側面から転倒） 左側面", "1ヘクスサイド左（側面から転倒） 左側面"])}).$freeze());
    Opal.const_set($nesting[0], 'HitPart', $$($nesting, 'Struct').$new("name", "critical_hit_may_occur"));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HitPart');

      var $nesting = [self].concat($parent_nesting);

      
      Opal.const_set($nesting[0], 'LEFT_TORSO', "左胴");
      Opal.const_set($nesting[0], 'CENTER_TORSO', "胴中央");
      Opal.const_set($nesting[0], 'RIGHT_TORSO', "右胴");
      Opal.const_set($nesting[0], 'LEFT_ARM', "左腕");
      Opal.const_set($nesting[0], 'RIGHT_ARM', "右腕");
      Opal.const_set($nesting[0], 'LEFT_LEG', "左脚");
      Opal.const_set($nesting[0], 'RIGHT_LEG', "右脚");
      Opal.const_set($nesting[0], 'HEAD', "頭");
      return Opal.const_set($nesting[0], 'TABLES', $hash2(["L", "C", "R", "LU", "CU", "RU", "LL", "CL", "RL"], {"L": $$($nesting, 'RangeTable').$new("命中部位表（左）", "2D6", [[2, self.$new($$($nesting, 'LEFT_TORSO'), true)], [3, self.$new($$($nesting, 'LEFT_LEG'), false)], [$range(4, 5, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [6, self.$new($$($nesting, 'LEFT_LEG'), false)], [7, self.$new($$($nesting, 'LEFT_TORSO'), false)], [8, self.$new($$($nesting, 'CENTER_TORSO'), false)], [9, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [10, self.$new($$($nesting, 'RIGHT_ARM'), false)], [11, self.$new($$($nesting, 'RIGHT_LEG'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]), "C": $$($nesting, 'RangeTable').$new("命中部位表（正面）", "2D6", [[2, self.$new($$($nesting, 'CENTER_TORSO'), true)], [$range(3, 4, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [5, self.$new($$($nesting, 'RIGHT_LEG'), false)], [6, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [7, self.$new($$($nesting, 'CENTER_TORSO'), false)], [8, self.$new($$($nesting, 'LEFT_TORSO'), false)], [9, self.$new($$($nesting, 'LEFT_LEG'), false)], [$range(10, 11, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]), "R": $$($nesting, 'RangeTable').$new("命中部位表（右）", "2D6", [[2, self.$new($$($nesting, 'RIGHT_TORSO'), true)], [3, self.$new($$($nesting, 'RIGHT_LEG'), false)], [$range(4, 5, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'RIGHT_LEG'), false)], [7, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [8, self.$new($$($nesting, 'CENTER_TORSO'), false)], [9, self.$new($$($nesting, 'LEFT_TORSO'), false)], [10, self.$new($$($nesting, 'LEFT_ARM'), false)], [11, self.$new($$($nesting, 'LEFT_LEG'), false)], [12, self.$new($$($nesting, 'HEAD'), false)]]), "LU": $$($nesting, 'RangeTable').$new("命中部位表（左上半身）", "1D6", [[$range(1, 2, false), self.$new($$($nesting, 'LEFT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [$range(4, 5, false), self.$new($$($nesting, 'LEFT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]), "CU": $$($nesting, 'RangeTable').$new("命中部位表（正面上半身）", "1D6", [[1, self.$new($$($nesting, 'LEFT_ARM'), false)], [2, self.$new($$($nesting, 'LEFT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [4, self.$new($$($nesting, 'RIGHT_TORSO'), false)], [5, self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]), "RU": $$($nesting, 'RangeTable').$new("命中部位表（右上半身）", "1D6", [[$range(1, 2, false), self.$new($$($nesting, 'RIGHT_TORSO'), false)], [3, self.$new($$($nesting, 'CENTER_TORSO'), false)], [$range(4, 5, false), self.$new($$($nesting, 'RIGHT_ARM'), false)], [6, self.$new($$($nesting, 'HEAD'), false)]]), "LL": $$($nesting, 'RangeTable').$new("命中部位表（左下半身）", "1D6", [[$range(1, 6, false), self.$new($$($nesting, 'LEFT_LEG'), false)]]), "CL": $$($nesting, 'RangeTable').$new("命中部位表（右下半身）", "1D6", [[$range(1, 3, false), self.$new($$($nesting, 'RIGHT_LEG'), false)], [$range(4, 6, false), self.$new($$($nesting, 'LEFT_LEG'), false)]]), "RL": $$($nesting, 'RangeTable').$new("命中部位表（右下半身）", "1D6", [[$range(1, 6, false), self.$new($$($nesting, 'RIGHT_LEG'), false)]])}).$freeze());
    })($nesting[0], null, $nesting);
    return Opal.const_set($nesting[0], 'XRM_DAMAGE_TABLES', $hash2(["SRM2", "SRM4", "SRM6", "LRM5", "LRM10", "LRM15", "LRM20"], {"SRM2": $$($nesting, 'RangeTable').$new("SRM2ダメージ表", "2D6", [[$range(2, 7, false), 1], [$range(8, 12, false), 2]]), "SRM4": $$($nesting, 'RangeTable').$new("SRM4ダメージ表", "2D6", [[2, 1], [$range(3, 6, false), 2], [$range(7, 10, false), 3], [$range(11, 12, false), 4]]), "SRM6": $$($nesting, 'RangeTable').$new("SRM6ダメージ表", "2D6", [[$range(2, 3, false), 2], [$range(4, 5, false), 3], [$range(6, 8, false), 4], [$range(9, 10, false), 5], [$range(11, 12, false), 6]]), "LRM5": $$($nesting, 'RangeTable').$new("LRM5ダメージ表", "2D6", [[2, 1], [$range(3, 4, false), 2], [$range(5, 8, false), 3], [$range(9, 10, false), 4], [$range(11, 12, false), 5]]), "LRM10": $$($nesting, 'RangeTable').$new("LRM10ダメージ表", "2D6", [[$range(2, 3, false), 3], [4, 4], [$range(5, 8, false), 6], [$range(9, 10, false), 8], [$range(11, 12, false), 10]]), "LRM15": $$($nesting, 'RangeTable').$new("LRM15ダメージ表", "2D6", [[$range(2, 3, false), 5], [4, 6], [$range(5, 8, false), 9], [$range(9, 10, false), 12], [$range(11, 12, false), 15]]), "LRM20": $$($nesting, 'RangeTable').$new("LRM20ダメージ表", "2D6", [[$range(2, 3, false), 6], [4, 9], [$range(5, 8, false), 12], [$range(9, 10, false), 16], [$range(11, 12, false), 20]])}).$freeze());
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting);
})(Opal);
