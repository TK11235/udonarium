/* Generated by Opal 1.0.3 */
Opal.modules["utils/table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$match', '$raise', '$to_i', '$[]', '$roll', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Table');

    var $nesting = [self].concat($parent_nesting), $Table_initialize$1, $Table_roll$2;

    self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
    
    
    Opal.def(self, '$initialize', $Table_initialize$1 = function $$initialize(name, type, items) {
      var self = this, m = nil;

      
      self.name = name;
      self.items = items.$freeze();
      m = /(\d+)D(\d+)/i.$match(type);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + (type))
      };
      self.times = m['$[]'](1).$to_i();
      return (self.sides = m['$[]'](2).$to_i());
    }, $Table_initialize$1.$$arity = 3);
    return (Opal.def(self, '$roll', $Table_roll$2 = function $$roll(bcdice) {
      var $a, $b, self = this, value = nil, index = nil;

      
      $b = bcdice.$roll(self.times, self.sides), $a = Opal.to_ary($b), (value = ($a[0] == null ? nil : $a[0])), $b;
      index = $rb_minus(value, self.times);
      return "" + (self.name) + "(" + (value) + ") ＞ " + (self.items['$[]'](index));
    }, $Table_roll$2.$$arity = 1), nil) && 'roll';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/range_table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$alias_method', '$freeze', '$lambda', '$name', '$sum', '$content', '$attr_reader', '$match', '$raise', '$to_i', '$[]', '$store', '$find', '$include?', '$range', '$roll', '$map', '$split', '$to_proc', '$fetch', '$formatted=', '$-', '$private', '$coerce_to_int_range', '$sort_by', '$min', '$assert_min_sum_is_covered', '$assert_max_sum_is_covered', '$assert_no_gap_or_overlap_in_ranges', '$===', '$is_a?', '$begin', '$end', '$class', '$first', '$*', '$last', '$each_cons', '$max', '$+']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeTable');

    var $nesting = [self].concat($parent_nesting), $RangeTable$1, $RangeTable$2, $RangeTable_initialize$3, $RangeTable_fetch$4, $RangeTable_roll$6, $RangeTable_store$7, $RangeTable_coerce_to_int_range$11, $RangeTable_assert_min_sum_is_covered$12, $RangeTable_assert_max_sum_is_covered$13, $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

    self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
    
    Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], ($RangeTable$1 = function(){var self = $RangeTable$1.$$s || this;

    return self.$alias_method("to_s", "formatted")}, $RangeTable$1.$$s = self, $RangeTable$1.$$arity = 0, $RangeTable$1)));
    Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
    Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
    Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($RangeTable$2 = function(table, result){var self = $RangeTable$2.$$s || this;

    
      
      if (table == null) {
        table = nil;
      };
      
      if (result == null) {
        result = nil;
      };
      return "" + (table.$name()) + "(" + (result.$sum()) + ") ＞ " + (result.$content());}, $RangeTable$2.$$s = self, $RangeTable$2.$$arity = 2, $RangeTable$2)));
    self.$attr_reader("name");
    self.$attr_reader("num_of_dice");
    self.$attr_reader("num_of_sides");
    
    Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
      var $iter = $RangeTable_initialize$3.$$p, formatter = $iter || nil, $a, self = this, m = nil;

      if ($iter) $RangeTable_initialize$3.$$p = null;
      
      
      if ($iter) $RangeTable_initialize$3.$$p = null;;
      self.name = name.$freeze();
      self.formatter = ($truthy($a = formatter) ? $a : $$($nesting, 'DEFAULT_FORMATTER'));
      m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (self.name) + ": invalid dice roll method: " + (dice_roll_method))
      };
      self.num_of_dice = m['$[]'](1).$to_i();
      self.num_of_sides = m['$[]'](2).$to_i();
      return self.$store(items);
    }, $RangeTable_initialize$3.$$arity = 3);
    
    Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
      var $$5, self = this, item = nil;

      
      item = $send(self.items, 'find', [], ($$5 = function(i){var self = $$5.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i.$range()['$include?'](value);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
      if ($truthy(item)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": value is out of range: " + (value))
      };
      return item;
    }, $RangeTable_fetch$4.$$arity = 1);
    
    Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(bcdice) {
      var $a, $b, self = this, sum = nil, values_str = nil, values = nil, result = nil, $writer = nil;

      
      $b = bcdice.$roll(self.num_of_dice, self.num_of_sides), $a = Opal.to_ary($b), (sum = ($a[0] == null ? nil : $a[0])), (values_str = ($a[1] == null ? nil : $a[1])), $b;
      values = $send(values_str.$split(","), 'map', [], "to_i".$to_proc());
      result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
      
      $writer = [self.formatter['$[]'](self, result)];
      $send(result, 'formatted=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return result;
    }, $RangeTable_roll$6.$$arity = 1);
    self.$private();
    
    Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
      var $$8, $$9, $$10, self = this, items_with_range = nil, sorted_items = nil;

      
      items_with_range = $send(items, 'map', [], ($$8 = function(r, c){var self = $$8.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (c == null) {
          c = nil;
        };
        return [self.$coerce_to_int_range(r), c];}, $$8.$$s = self, $$8.$$arity = 2, $$8));
      sorted_items = $send(items_with_range, 'sort_by', [], ($$9 = function(r, _){var self = $$9.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return r.$min();}, $$9.$$s = self, $$9.$$arity = 2, $$9));
      self.$assert_min_sum_is_covered(sorted_items);
      self.$assert_max_sum_is_covered(sorted_items);
      self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
      self.items = $send(sorted_items, 'map', [], ($$10 = function(range, content){var self = $$10.$$s || this;

      
        
        if (range == null) {
          range = nil;
        };
        
        if (content == null) {
          content = nil;
        };
        return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();}, $$10.$$s = self, $$10.$$arity = 2, $$10)).$freeze();
      return self;
    }, $RangeTable_store$7.$$arity = 1);
    
    Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
      var $a, self = this, $case = nil;

      
      $case = x;
      if ($$($nesting, 'Integer')['$===']($case)) {return $$($nesting, 'Range').$new(x, x)}
      else if ($$($nesting, 'Range')['$===']($case)) {if ($truthy(($truthy($a = x.$begin()['$is_a?']($$($nesting, 'Integer'))) ? x.$end()['$is_a?']($$($nesting, 'Integer')) : $a))) {
        return x}};
      return self.$raise($$($nesting, 'TypeError'), "" + (self.name) + ": " + (x) + " (" + (x.$class()) + ") must be an Integer or a Range with Integers ");
    }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
    
    Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
      var self = this, min_sum = nil, range = nil;

      
      min_sum = self.num_of_dice;
      range = sorted_items.$first()['$[]'](0);
      if ($truthy(range['$include?'](min_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": min value (" + (min_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
    
    Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
      var self = this, max_sum = nil, range = nil;

      
      max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
      range = sorted_items.$last()['$[]'](0);
      if ($truthy(range['$include?'](max_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": max value (" + (max_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
    return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
      var $$15, self = this;

      
      $send(sorted_items, 'each_cons', [2], ($$15 = function(i1, i2){var self = $$15.$$s || this, r1 = nil, r2 = nil, max1 = nil, next_of_max1 = nil;
        if (self.name == null) self.name = nil;

      
        
        if (i1 == null) {
          i1 = nil;
        };
        
        if (i2 == null) {
          i2 = nil;
        };
        r1 = i1['$[]'](0);
        r2 = i2['$[]'](0);
        max1 = r1.$max();
        next_of_max1 = $rb_plus(max1, 1);
        if ($truthy(r2['$include?'](max1))) {
          self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range overlap: " + (r1) + " and " + (r2))};
        if ($truthy(r2['$include?'](next_of_max1))) {
          return nil
        } else {
          return self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range gap: " + (r1) + " and " + (r2))
        };}, $$15.$$s = self, $$15.$$arity = 2, $$15));
      return self;
    }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$require', '$===', '$check_1D12', '$getTrapResult', '$getEscapeExperienceTableResult', '$roll_tables', '$debug', '$match', '$to_i', '$parren_killer', '$[]', '$+', '$floor', '$/', '$roll', '$==', '$<=', '$freeze', '$new', '$setPrefixes', '$keys']);
  
  self.$require("utils/table.rb");
  self.$require("utils/range_table");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KemonoNoMori');

    var $nesting = [self].concat($parent_nesting), $KemonoNoMori_rollDiceCommand$1, $KemonoNoMori_check_1D12$2, $KemonoNoMori_getTrapResult$3, $KemonoNoMori_getEscapeExperienceTableResult$4;

    
    Opal.const_set($nesting[0], 'ID', "KemonoNoMori");
    Opal.const_set($nesting[0], 'NAME', "獸ノ森");
    Opal.const_set($nesting[0], 'SORT_KEY', "けもののもり");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・行為判定(成功度自動算出): KAx[±y]\n" + "・継続判定(成功度+1固定): KCx[±y]\n" + "   x=目標値\n" + "   y=目標値への修正(任意) x+y-z のように複数指定可能\n" + "     例1）KA7+3 → 目標値7にプラス3の修正を加えた行為判定\n" + "     例2）KC6 → 目標値6の継続判定\n" + "・罠動作判定: CTR\n" + "   罠ごとに1D12を振る。12が出た場合は罠が動作し、獲物がその効果を受ける\n" + "・各種表\n" + "  ・大失敗表: FT\n" + "  ・能力値ランダム決定表: RST\n" + "  ・ランダム所要時間表: RTT\n" + "  ・ランダム消耗表: RET\n" + "  ・ランダム天気表: RWT\n" + "  ・ランダム天気持続表: RWDT\n" + "  ・ランダム遮蔽物表（屋外）: ROMT\n" + "  ・ランダム遮蔽物表（屋内）: RIMT\n" + "  ・逃走体験表: EET\n" + "  ・食材採集表: GFT\n" + "  ・水採集表: GWT\n" + "  ・白の魔石効果表: WST\n");
    
    Opal.def(self, '$rollDiceCommand', $KemonoNoMori_rollDiceCommand$1 = function $$rollDiceCommand(command) {
      var self = this, $case = nil;

      return (function() {$case = command;
      if (/KA\d[-+\d]*/['$===']($case)) {return self.$check_1D12(command, true)}
      else if (/KC\d[-+\d]*/['$===']($case)) {return self.$check_1D12(command, false)}
      else if ("CTR"['$===']($case)) {return self.$getTrapResult()}
      else if ("EET"['$===']($case)) {return self.$getEscapeExperienceTableResult(command)}
      else {return self.$roll_tables(command, $$($nesting, 'TABLES'))}})()
    }, $KemonoNoMori_rollDiceCommand$1.$$arity = 1);
    
    Opal.def(self, '$check_1D12', $KemonoNoMori_check_1D12$2 = function $$check_1D12(command, is_action_judge) {
      var $a, $b, self = this, m = nil, target_total = nil, success_degree = nil, dice_total = nil;

      
      self.$debug("獸ノ森の1d12判定");
      m = /K[AC](\d[-+\d]*)/.$match(command);
      if ($truthy(m)) {
      } else {
        return ""
      };
      target_total = self.$parren_killer("" + "(" + (m['$[]'](1)) + ")").$to_i();
      self.$debug("target_total", target_total);
      success_degree = (function() {if ($truthy(is_action_judge)) {
        return $rb_plus($rb_divide(target_total, 10).$floor(), 1)
      } else {
        return 1
      }; return nil; })();
      $b = self.$roll(1, 12), $a = Opal.to_ary($b), (dice_total = ($a[0] == null ? nil : $a[0])), $b;
      self.$debug("dice_total, target_total, success_degree = ", dice_total, target_total, success_degree);
      if (dice_total['$=='](12)) {
        return "" + "(1D12<=" + (target_total) + ") ＞ " + (dice_total) + " ＞ 大失敗"
      } else if (dice_total['$=='](11)) {
        return "" + "(1D12<=" + (target_total) + ") ＞ " + (dice_total) + " ＞ 大成功（成功度+" + (success_degree) + ", 次の継続判定の目標値を10に変更）"
      } else if ($truthy($rb_le(dice_total, target_total))) {
        return "" + "(1D12<=" + (target_total) + ") ＞ " + (dice_total) + " ＞ 成功（成功度+" + (success_degree) + "）"
      } else {
        return "" + "(1D12<=" + (target_total) + ") ＞ " + (dice_total) + " ＞ 失敗"
      };
    }, $KemonoNoMori_check_1D12$2.$$arity = 2);
    
    Opal.def(self, '$getTrapResult', $KemonoNoMori_getTrapResult$3 = function $$getTrapResult() {
      var $a, $b, self = this, trapCheckNumber = nil, chaseNumber = nil, chase = nil, $case = nil;

      
      $b = self.$roll(1, 12), $a = Opal.to_ary($b), (trapCheckNumber = ($a[0] == null ? nil : $a[0])), $b;
      if (trapCheckNumber['$=='](12)) {
        
        $b = self.$roll(1, 12), $a = Opal.to_ary($b), (chaseNumber = ($a[0] == null ? nil : $a[0])), $b;
        chase = nil;
        $case = chaseNumber;
        if ((1)['$===']($case) || (2)['$===']($case) || (3)['$===']($case) || (4)['$===']($case)) {chase = "小型動物"}
        else if ((5)['$===']($case) || (6)['$===']($case) || (7)['$===']($case) || (8)['$===']($case)) {chase = "大型動物"}
        else if ((9)['$===']($case) || (10)['$===']($case) || (11)['$===']($case) || (12)['$===']($case)) {chase = "人間の放浪者"};
        return "" + "罠動作チェック(1D12) ＞ " + (trapCheckNumber) + " ＞ 罠が動作していた！ ＞ 獲物表(" + (chaseNumber) + ") ＞ " + (chase) + "が罠にかかっていた";};
      return "" + "罠動作チェック(1D12) ＞ " + (trapCheckNumber) + " ＞ 罠は動作していなかった";
    }, $KemonoNoMori_getTrapResult$3.$$arity = 0);
    
    Opal.def(self, '$getEscapeExperienceTableResult', $KemonoNoMori_getEscapeExperienceTableResult$4 = function $$getEscapeExperienceTableResult(command) {
      var $a, $b, self = this, escapeExperience = nil, escapeDuration = nil;

      
      escapeExperience = self.$roll_tables(command, $$($nesting, 'TABLES'));
      $b = self.$roll(1, 12), $a = Opal.to_ary($b), (escapeDuration = ($a[0] == null ? nil : $a[0])), $b;
      return "" + (escapeExperience) + " (再登場: " + (escapeDuration) + "時間後)";
    }, $KemonoNoMori_getEscapeExperienceTableResult$4.$$arity = 1);
    Opal.const_set($nesting[0], 'TABLES', $hash2(["FT", "RST", "RTT", "RET", "RWT", "RWDT", "ROMT", "RIMT", "EET", "GFT", "GWT", "WST"], {"FT": $$($nesting, 'RangeTable').$new("大失敗表", "1D12", [[$range(1, 3, false), "【余裕】が3点減少する（最低0まで）"], [$range(4, 5, false), "ランダムな荷物1個が落ちて行方不明になる（大失敗したエリアのアイテム調査で見つけることが可能）"], [$range(6, 7, false), "ランダムな荷物1個が破壊される"], [$range(8, 9, false), "ランダム天気表を使用し、結果をターンの終了まで適用する"], [10, "ランダムな準備している小道具1個が破壊される"], [11, "着想している防具が破壊される"], [12, "準備している武器が破壊される"]]), "RST": $$($nesting, 'RangeTable').$new("能力値ランダム決定表", "1D12", [[$range(1, 2, false), "【移動】"], [$range(3, 4, false), "【格闘】"], [$range(5, 6, false), "【射撃】"], [$range(7, 8, false), "【製作】"], [$range(9, 10, false), "【察知】"], [$range(11, 12, false), "【自制】"]]), "RTT": $$($nesting, 'RangeTable').$new("ランダム所要時間表", "1D12", [[$range(1, 3, false), "2"], [$range(4, 6, false), "3"], [$range(7, 9, false), "4"], [$range(10, 12, false), "5"]]), "RET": $$($nesting, 'RangeTable').$new("ランダム消耗表", "1D12", [[$range(1, 3, false), "0"], [$range(4, 6, false), "1"], [$range(7, 9, false), "2"], [$range(10, 12, false), "4"]]), "RWT": $$($nesting, 'RangeTable').$new("ランダム天気表", "1D12", [[$range(1, 2, false), "濃霧"], [$range(3, 4, false), "大雨"], [$range(5, 6, false), "雷雨"], [$range(7, 8, false), "強風"], [$range(9, 10, false), "酷暑"], [$range(11, 12, false), "極寒"]]), "RWDT": $$($nesting, 'RangeTable').$new("ランダム天気持続表", "1D12", [[$range(1, 2, false), "1ターン"], [$range(3, 4, false), "3ターン"], [$range(5, 6, false), "6ターン"], [$range(7, 8, false), "24ターン"], [$range(9, 10, false), "72ターン"], [$range(11, 12, false), "156ターン"]]), "ROMT": $$($nesting, 'RangeTable').$new("ランダム遮蔽物表(屋外)", "1D12", [[$range(1, 2, false), "【藪】耐久度3,軽減値1,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(3, 5, false), "【木】耐久度5,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(6, 8, false), "【大木】耐久度7,軽減値3,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-2の修正を付加"], [$range(9, 10, false), "【岩】耐久度6,軽減値4,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加/コンタクト内で行われる格闘攻撃のダメージ+1"], [$range(11, 12, false), "【岩壁】耐久度8,軽減値4,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-2の修正を付加/コンタクト内で行われる格闘攻撃のダメージ+2"]]), "RIMT": $$($nesting, 'RangeTable').$new("ランダム遮蔽物表(屋内)", "1D12", [[$range(1, 4, false), "【木材の壁】耐久度4,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1の修正を付加"], [$range(5, 8, false), "【木材の扉】耐久度4,軽減値2,特殊効果:コンタクト内のキャラクターに対する射撃攻撃判定に-1、接触判定と突撃判定に-2の修正を付加"], [$range(9, 12, false), "【木製家具】耐久度3,軽減値2,特殊効果:コンタクト内で行われる格闘攻撃のダメージ+1"]]), "EET": $$($nesting, 'RangeTable').$new("逃走体験表", "1D12", [[$range(1, 3, false), "【余裕】が0になる"], [$range(4, 6, false), "任意の【絆】を合計2点減少する"], [$range(7, 9, false), "全ての荷物を失う（逃走したエリアに配置され、調査で発見可能）"], [$range(10, 12, false), "全ての武器と防具と小道具と荷物を失う（逃走したエリアに配置され、調査で発見可能）"]]), "GFT": $$($nesting, 'RangeTable').$new("食材採集表", "1D12", [[$range(1, 2, false), "食べられる根（栄養価:2）"], [$range(3, 5, false), "食べられる草（栄養価:3）"], [$range(6, 8, false), "食べられる実（栄養価:5）"], [$range(9, 10, false), "小型動物（栄養価:10）"], [11, "大型動物（栄養価:40）"], [12, "気持ち悪い虫（栄養価:1）"]]), "GWT": $$($nesting, 'RangeTable').$new("水採集表", "1D12", [[$range(1, 6, false), "汚水"], [$range(7, 11, false), "飲料水"], [12, "毒水"]]), "WST": $$($nesting, 'Table').$new("白の魔石効果表", "1D12", ["役に立たないものの色を変える", "役に立たないものを大きくする", "役に立たないものを小さくする", "役に立たないものを保存する", "役に立たないものを復元する", "役に立たないものを召喚する", "役に立たないものを動かす", "役に立たないものを増やす", "役に立たないものを貼り付ける", "役に立たないものを作り出す", "小型動物を召喚する", "大型動物を召喚する"])}).$freeze());
    return self.$setPrefixes($rb_plus(["K[AC]\\d[-+\\d]*", "CTR"], $$($nesting, 'TABLES').$keys()));
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting);
})(Opal);
