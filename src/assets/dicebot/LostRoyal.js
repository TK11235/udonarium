/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $range = Opal.range, $truthy = Opal.truthy;

  Opal.add_stubs(['$setPrefixes', '$===', '$check_lostroyal', '$to_i', '$last_match', '$roll_fumble_chart', '$roll_wind_power_chart', '$roll_emotion_chart', '$roll_hope', '$each', '$roll', '$<<', '$to_a', '$map', '$[]', '$-', '$inject', '$find_sequence', '$join', '$nil?', '$empty?', '$fumble?', '$size', '$+', '$>=', '$sort', '$find_sequence_from_start_key', '$max', '$select', '$>', '$<=>', '$include?', '$!', '$==', '$unshift', '$count', '$loop', '$min', '$!=', '$is_1or2']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LostRoyal');

    var $nesting = [self].concat($parent_nesting), $LostRoyal_initialize$1, $LostRoyal_rollDiceCommand$2, $LostRoyal_check_lostroyal$3, $LostRoyal_find_sequence$6, $LostRoyal_find_sequence_from_start_key$10, $LostRoyal_fumble$ques$11, $LostRoyal_roll_fumble_chart$13, $LostRoyal_roll_wind_power_chart$14, $LostRoyal_roll_emotion_chart$16, $LostRoyal_roll_hope$17, $LostRoyal_is_1or2$19;

    
    Opal.const_set($nesting[0], 'ID', "LostRoyal");
    Opal.const_set($nesting[0], 'NAME', "ロストロイヤル");
    Opal.const_set($nesting[0], 'SORT_KEY', "ろすとろいやる");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・D66ダイスあり\n" + "\n" + "行為判定\n" + "　LR[x,x,x,x,x,x]\n" + "　　x の並びには【判定表】の数値を順番に入力する。\n" + "　　（例： LR[1,3,0,1,2] ）\n" + "\n" + "ファンブル表\n" + "　FC\n" + "\n" + "風力決定表\n" + "　WPC\n" + "\n" + "感情決定表\n" + "　EC\n" + "\n" + "希望点の決定\n" + "　HRx\n" + "　　x にはダイスの数（ 1 - 2 ）を指定\n");
    self.$setPrefixes(["LR\\[[0-5],[0-5],[0-5],[0-5],[0-5],[0-5]\\]", "FC", "WPC", "EC", "HR[1-2]"]);
    
    Opal.def(self, '$initialize', $LostRoyal_initialize$1 = function $$initialize() {
      var $iter = $LostRoyal_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $LostRoyal_initialize$1.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $LostRoyal_initialize$1, false), $zuper, $iter);
      self.sendMode = 2;
      self.sortType = 1;
      return (self.d66Type = 1);
    }, $LostRoyal_initialize$1.$$arity = 0);
    
    Opal.def(self, '$rollDiceCommand', $LostRoyal_rollDiceCommand$2 = function $$rollDiceCommand(command) {
      var self = this, $case = nil;

      
      $case = command;
      if (/LR\[([0-5]),([0-5]),([0-5]),([0-5]),([0-5]),([0-5])\]/i['$===']($case)) {return self.$check_lostroyal([$$($nesting, 'Regexp').$last_match(1).$to_i(), $$($nesting, 'Regexp').$last_match(2).$to_i(), $$($nesting, 'Regexp').$last_match(3).$to_i(), $$($nesting, 'Regexp').$last_match(4).$to_i(), $$($nesting, 'Regexp').$last_match(5).$to_i(), $$($nesting, 'Regexp').$last_match(6).$to_i()])}
      else if (/FC/['$===']($case)) {return self.$roll_fumble_chart()}
      else if (/WPC/['$===']($case)) {return self.$roll_wind_power_chart()}
      else if (/EC/['$===']($case)) {return self.$roll_emotion_chart()}
      else if (/HR([1-2])/['$===']($case)) {return self.$roll_hope($$($nesting, 'Regexp').$last_match(1).$to_i())};
      return nil;
    }, $LostRoyal_rollDiceCommand$2.$$arity = 1);
    
    Opal.def(self, '$check_lostroyal', $LostRoyal_check_lostroyal$3 = function $$check_lostroyal(checking_table) {
      var $$4, $$5, $a, self = this, keys = nil, scores = nil, total_score = nil, chained_sequence = nil, text = nil, bonus = nil;

      
      keys = [];
      $send($range(0, 3, true), 'each', [], ($$4 = function(_i){var self = $$4.$$s || this, $a, $b, key = nil;

      
        
        if (_i == null) {
          _i = nil;
        };
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
        return keys['$<<'](key);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
      scores = $send(keys, 'map', [], ($$5 = function(k){var self = $$5.$$s || this;

      
        
        if (k == null) {
          k = nil;
        };
        return checking_table['$[]']($rb_minus(k, 1));}, $$5.$$s = self, $$5.$$arity = 1, $$5)).$to_a();
      total_score = scores.$inject("+");
      chained_sequence = self.$find_sequence(keys);
      text = "" + "3D6 => [" + (keys.$join(",")) + "] => (" + (scores.$join("+")) + ") => " + (total_score);
      if ($truthy(($truthy($a = chained_sequence['$nil?']()) ? $a : chained_sequence['$empty?']()))) {
      } else {
        
        bonus = (function() {if ($truthy(self['$fumble?'](keys, chained_sequence))) {
          return 3
        } else {
          return chained_sequence.$size()
        }; return nil; })();
        text = $rb_plus(text, "" + " | " + (chained_sequence.$size()) + " chain! (" + (chained_sequence.$join(",")) + ") => " + ($rb_plus(total_score, bonus)));
        if ($truthy($rb_ge(chained_sequence.$size(), 3))) {
          text = $rb_plus(text, " [スペシャル]")};
        if ($truthy(self['$fumble?'](keys, chained_sequence))) {
          text = $rb_plus(text, " [ファンブル]")};
      };
      return text;
    }, $LostRoyal_check_lostroyal$3.$$arity = 1);
    
    Opal.def(self, '$find_sequence', $LostRoyal_find_sequence$6 = function $$find_sequence(keys) {
      var $$7, $$8, $$9, self = this, sequences = nil, sequence = nil;

      
      keys = keys.$sort();
      sequences = $send($range(1, 6, true), 'map', [], ($$7 = function(start_key){var self = $$7.$$s || this;

      
        
        if (start_key == null) {
          start_key = nil;
        };
        return self.$find_sequence_from_start_key(keys, start_key);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
      sequence = $send($send(sequences, 'select', [], ($$8 = function(x){var self = $$8.$$s || this;

      
        
        if (x == null) {
          x = nil;
        };
        return $rb_gt(x.$size(), 1);}, $$8.$$s = self, $$8.$$arity = 1, $$8)), 'max', [], ($$9 = function(a, b){var self = $$9.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a.$size()['$<=>'](b.$size());}, $$9.$$s = self, $$9.$$arity = 2, $$9));
      return sequence;
    }, $LostRoyal_find_sequence$6.$$arity = 1);
    
    Opal.def(self, '$find_sequence_from_start_key', $LostRoyal_find_sequence_from_start_key$10 = function $$find_sequence_from_start_key(keys, start_key) {
      var $a, self = this, chained_keys = nil, key = nil;

      
      chained_keys = [];
      key = start_key;
      while ($truthy(keys['$include?'](key))) {
        
        chained_keys['$<<'](key);
        key = $rb_plus(key, 1);
      };
      if ($truthy(($truthy($a = chained_keys['$empty?']()['$!']()) ? chained_keys['$[]'](0)['$=='](1) : $a))) {
        
        key = 6;
        while ($truthy(keys['$include?'](key))) {
          
          chained_keys.$unshift(key);
          key = $rb_minus(key, 1);
        };};
      return chained_keys;
    }, $LostRoyal_find_sequence_from_start_key$10.$$arity = 2);
    
    Opal.def(self, '$fumble?', $LostRoyal_fumble$ques$11 = function(keys, chained_sequence) {try {

      var $$12, self = this;

      
      $send(chained_sequence, 'each', [], ($$12 = function(k){var self = $$12.$$s || this;

      
        
        if (k == null) {
          k = nil;
        };
        if ($truthy($rb_ge(keys.$count(k), 2))) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$12.$$s = self, $$12.$$arity = 1, $$12));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $LostRoyal_fumble$ques$11.$$arity = 2);
    
    Opal.def(self, '$roll_fumble_chart', $LostRoyal_roll_fumble_chart$13 = function $$roll_fumble_chart() {
      var $a, $b, self = this, key = nil, text = nil;

      
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
      text = ["何かの問題で言い争い、主君に無礼を働いてしまう。あなたは主君の名誉点を１点失うか、【時間】を１点消費して和解の話し合いを持つか選べる。", "見過ごせば人々を不幸にする危険に遭遇する。あなたは逃げ出して冒険の名誉点を１点失うか、これに立ち向かい【命数】を２点減らすかを選べる。", "あなたが惹かれたのは好意に付け込む人だった。あなたはその場を去って恋慕の名誉点を１点失うか【正義】を１点減らして礼を尽くすかを選べる。", "金銭的な問題で、生命と魂の苦しみを背負う人に出会う。あなたは庇護の名誉点を１点失うか出費を３点増やすかを選べる。", "襲撃を受ける。苦もなく叩き伏せると、卑屈な態度で命乞いをしてきた。容赦なく命を奪い寛容の名誉点を１点失うか、密告によって【血路】が１Ｄ６点増えるかを選ぶことができる。", "風聞により、友が悪に身を貶めたと知る。共に並んだ戦場が色褪せる想いだ。戦友の名誉点を１点減らすか、【酒と歌】すべてを失うかを選べる。"]['$[]']($rb_minus(key, 1));
      return "" + "1D6 => [" + (key) + "] " + (text);
    }, $LostRoyal_roll_fumble_chart$13.$$arity = 0);
    
    Opal.def(self, '$roll_wind_power_chart', $LostRoyal_roll_wind_power_chart$14 = function $$roll_wind_power_chart() {try {

      var $$15, self = this, key = nil, total_bonus = nil, text = nil;

      
      key = 0;
      total_bonus = 0;
      text = "";
      return $send(self, 'loop', [], ($$15 = function(){var self = $$15.$$s || this, $a, $b, dice = nil, add = nil, bonus = nil, current_text = nil;

      
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice = ($a[0] == null ? nil : $a[0])), $b;
        key = $rb_plus(key, dice);
        $b = [[true, 0, "ほぼ凪（振り足し）"], [true, 0, "弱い風（振り足し）"], [false, 0, "ゆるやかな風"], [false, 0, "ゆるやかな風"], [false, 1, "やや強い風（儀式点プラス１）"], [false, 2, "強い風（龍を幻視、儀式点プラス２）"], [false, 3, "体が揺らぐほどの風（龍を幻視、儀式点プラス３）"]]['$[]']($rb_minus([key, 7].$min(), 1)), $a = Opal.to_ary($b), (add = ($a[0] == null ? nil : $a[0])), (bonus = ($a[1] == null ? nil : $a[1])), (current_text = ($a[2] == null ? nil : $a[2])), $b;
        total_bonus = $rb_plus(total_bonus, bonus);
        if ($truthy(key['$!='](dice))) {
          current_text = "" + "1D6[" + (dice) + "]+" + ($rb_minus(key, dice)) + " " + (current_text)
        } else {
          current_text = "" + "1D6[" + (dice) + "] " + (current_text)
        };
        if ($truthy(text['$empty?']())) {
          text = current_text
        } else {
          text = "" + (text) + " => " + (current_text)
        };
        if ($truthy(add)) {
          return nil
        } else {
          
          text = $rb_plus(text, "" + " [合計：儀式点 +" + (total_bonus) + " ]");
          Opal.ret(text);
        };}, $$15.$$s = self, $$15.$$arity = 0, $$15));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $LostRoyal_roll_wind_power_chart$14.$$arity = 0);
    
    Opal.def(self, '$roll_emotion_chart', $LostRoyal_roll_emotion_chart$16 = function $$roll_emotion_chart() {
      var $a, $b, self = this, key = nil, text = nil;

      
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
      text = ["愛情／殺意", "友情／負目", "崇拝／嫌悪", "興味／侮蔑", "信頼／嫉妬", "守護／欲情"]['$[]']($rb_minus(key, 1));
      return "" + "1D6 => [" + (key) + "] " + (text);
    }, $LostRoyal_roll_emotion_chart$16.$$arity = 0);
    
    Opal.def(self, '$roll_hope', $LostRoyal_roll_hope$17 = function $$roll_hope(number_of_dice) {try {

      var $$18, self = this, total = nil, text = nil;

      
      total = 0;
      text = "";
      return $send(self, 'loop', [], ($$18 = function(){var self = $$18.$$s || this, $a, $b, d1 = nil, d2 = nil;

      
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (d1 = ($a[0] == null ? nil : $a[0])), $b;
        d2 = 0;
        if ($truthy($rb_ge(number_of_dice, 2))) {
          $b = self.$roll(1, 6), $a = Opal.to_ary($b), (d2 = ($a[0] == null ? nil : $a[0])), $b};
        total = $rb_plus(total, $rb_plus(d1, d2));
        if (number_of_dice['$=='](2)) {
          text = $rb_plus(text, "" + "2D6[" + (d1) + "," + (d2) + "]")
        } else {
          text = $rb_plus(text, "" + "1D6[" + (d1) + "]")
        };
        if ($truthy(($truthy($a = self.$is_1or2(d1)) ? $a : self.$is_1or2(d2)))) {
          return (text = $rb_plus(text, " （振り足し） => "))
        } else {
          
          text = $rb_plus(text, "" + " => 合計 " + (total));
          Opal.ret(text);
        };}, $$18.$$s = self, $$18.$$arity = 0, $$18));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $LostRoyal_roll_hope$17.$$arity = 1);
    return (Opal.def(self, '$is_1or2', $LostRoyal_is_1or2$19 = function $$is_1or2(n) {
      var self = this;

      return [1, 2]['$include?'](n)
    }, $LostRoyal_is_1or2$19.$$arity = 1), nil) && 'is_1or2';
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting)
})(Opal);
