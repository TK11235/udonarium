/* Generated by Opal 0.11.4 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $range = Opal.range, $truthy = Opal.truthy;

  Opal.add_stubs(['$setPrefixes', '$===', '$check_lostroyal', '$to_i', '$last_match', '$roll_fumble_chart', '$roll_wind_power_chart', '$roll_emotion_chart', '$roll_hope', '$each', '$roll', '$<<', '$to_a', '$map', '$[]', '$-', '$inject', '$find_sequence', '$join', '$nil?', '$empty?', '$is_fumble?', '$size', '$+', '$>=', '$sort', '$max', '$find_all', '$find_sequence_from_start_key', '$>', '$<=>', '$include?', '$!', '$==', '$unshift', '$count', '$loop', '$min', '$!=', '$is_1or2']);
  return (function($base, $super, $parent_nesting) {
    function $LostRoyal(){};
    var self = $LostRoyal = $klass($base, $super, 'LostRoyal', $LostRoyal);

    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_LostRoyal_initialize_1, TMP_LostRoyal_gameName_2, TMP_LostRoyal_gameType_3, TMP_LostRoyal_getHelpMessage_4, TMP_LostRoyal_rollDiceCommand_5, TMP_LostRoyal_check_lostroyal_8, TMP_LostRoyal_find_sequence_12, TMP_LostRoyal_find_sequence_from_start_key_13, TMP_LostRoyal_is_fumble$q_15, TMP_LostRoyal_roll_fumble_chart_16, TMP_LostRoyal_roll_wind_power_chart_18, TMP_LostRoyal_roll_emotion_chart_19, TMP_LostRoyal_roll_hope_21, TMP_LostRoyal_is_1or2_22;

    
    self.$setPrefixes(["LR\\[[0-5],[0-5],[0-5],[0-5],[0-5],[0-5]\\]", "FC", "WPC", "EC", "HR[1-2]"]);
    
    Opal.defn(self, '$initialize', TMP_LostRoyal_initialize_1 = function $$initialize() {
      var self = this, $iter = TMP_LostRoyal_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) TMP_LostRoyal_initialize_1.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_LostRoyal_initialize_1, false), $zuper, $iter);
      self.sendMode = 2;
      self.sortType = 1;
      return (self.d66Type = 1);
    }, TMP_LostRoyal_initialize_1.$$arity = 0);
    
    Opal.defn(self, '$gameName', TMP_LostRoyal_gameName_2 = function $$gameName() {
      var self = this;

      return "ロストロイヤル"
    }, TMP_LostRoyal_gameName_2.$$arity = 0);
    
    Opal.defn(self, '$gameType', TMP_LostRoyal_gameType_3 = function $$gameType() {
      var self = this;

      return "LostRoyal"
    }, TMP_LostRoyal_gameType_3.$$arity = 0);
    
    Opal.defn(self, '$getHelpMessage', TMP_LostRoyal_getHelpMessage_4 = function $$getHelpMessage() {
      var self = this;

      return "" + "・D66ダイスあり\n" + "\n" + "行為判定\n" + "　LR[x,x,x,x,x,x]\n" + "　　x の並びには【判定表】の数値を順番に入力する。\n" + "　　（例： LR[1,3,0,1,2] ）\n" + "\n" + "ファンブル表\n" + "　FC\n" + "\n" + "風力決定表\n" + "　WPC\n" + "\n" + "感情決定表\n" + "　EC\n" + "\n" + "希望点の決定\n" + "　HRx\n" + "　　x にはダイスの数（ 1 - 2 ）を指定\n"
    }, TMP_LostRoyal_getHelpMessage_4.$$arity = 0);
    
    Opal.defn(self, '$rollDiceCommand', TMP_LostRoyal_rollDiceCommand_5 = function $$rollDiceCommand(command) {
      var self = this, $case = nil;

      
      $case = command;
      if (/LR\[([0-5]),([0-5]),([0-5]),([0-5]),([0-5]),([0-5])\]/i['$===']($case)) {return self.$check_lostroyal([Opal.const_get_relative($nesting, 'Regexp').$last_match(1).$to_i(), Opal.const_get_relative($nesting, 'Regexp').$last_match(2).$to_i(), Opal.const_get_relative($nesting, 'Regexp').$last_match(3).$to_i(), Opal.const_get_relative($nesting, 'Regexp').$last_match(4).$to_i(), Opal.const_get_relative($nesting, 'Regexp').$last_match(5).$to_i(), Opal.const_get_relative($nesting, 'Regexp').$last_match(6).$to_i()])}
      else if (/FC/['$===']($case)) {return self.$roll_fumble_chart()}
      else if (/WPC/['$===']($case)) {return self.$roll_wind_power_chart()}
      else if (/EC/['$===']($case)) {return self.$roll_emotion_chart()}
      else if (/HR([1-2])/['$===']($case)) {return self.$roll_hope(Opal.const_get_relative($nesting, 'Regexp').$last_match(1).$to_i())};
      return nil;
    }, TMP_LostRoyal_rollDiceCommand_5.$$arity = 1);
    
    Opal.defn(self, '$check_lostroyal', TMP_LostRoyal_check_lostroyal_8 = function $$check_lostroyal(checking_table) {
      var TMP_6, TMP_7, $a, self = this, keys = nil, scores = nil, total_score = nil, chained_sequence = nil, text = nil, bonus = nil;

      
      keys = [];
      $send($range(0, 3, true), 'each', [], (TMP_6 = function(_i){var self = TMP_6.$$s || this, $a, $b, key = nil;
if (_i == null) _i = nil;
      
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
        return keys['$<<'](key);}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));
      scores = $send(keys, 'map', [], (TMP_7 = function(k){var self = TMP_7.$$s || this;
if (k == null) k = nil;
      return checking_table['$[]']($rb_minus(k, 1))}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7)).$to_a();
      total_score = scores.$inject("+");
      chained_sequence = self.$find_sequence(keys);
      text = "" + "3D6 => [" + (keys.$join(",")) + "] => (" + (scores.$join("+")) + ") => " + (total_score);
      if ($truthy(($truthy($a = chained_sequence['$nil?']()) ? $a : chained_sequence['$empty?']()))) {
        } else {
        
        bonus = (function() {if ($truthy(self['$is_fumble?'](keys, chained_sequence))) {
          return 3
          } else {
          return chained_sequence.$size()
        }; return nil; })();
        text = $rb_plus(text, "" + " | " + (chained_sequence.$size()) + " chain! (" + (chained_sequence.$join(",")) + ") => " + ($rb_plus(total_score, bonus)));
        if ($truthy($rb_ge(chained_sequence.$size(), 3))) {
          text = $rb_plus(text, " [スペシャル]")};
        if ($truthy(self['$is_fumble?'](keys, chained_sequence))) {
          text = $rb_plus(text, " [ファンブル]")};
      };
      return text;
    }, TMP_LostRoyal_check_lostroyal_8.$$arity = 1);
    
    Opal.defn(self, '$find_sequence', TMP_LostRoyal_find_sequence_12 = function $$find_sequence(keys) {
      var TMP_9, TMP_10, TMP_11, self = this, sequence = nil;

      
      keys = keys.$sort();
      sequence = $send($send($send($range(1, 6, true), 'map', [], (TMP_9 = function(start_key){var self = TMP_9.$$s || this;
if (start_key == null) start_key = nil;
      return self.$find_sequence_from_start_key(keys, start_key)}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9)), 'find_all', [], (TMP_10 = function(x){var self = TMP_10.$$s || this;
if (x == null) x = nil;
      return $rb_gt(x.$size(), 1)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10)), 'max', [], (TMP_11 = function(a, b){var self = TMP_11.$$s || this;
if (a == null) a = nil;if (b == null) b = nil;
      return a.$size()['$<=>'](b.$size())}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));
      return sequence;
    }, TMP_LostRoyal_find_sequence_12.$$arity = 1);
    
    Opal.defn(self, '$find_sequence_from_start_key', TMP_LostRoyal_find_sequence_from_start_key_13 = function $$find_sequence_from_start_key(keys, start_key) {
      var $a, self = this, chained_keys = nil, key = nil;

      
      chained_keys = [];
      key = start_key;
      while ($truthy(keys['$include?'](key))) {
        
        chained_keys['$<<'](key);
        key = $rb_plus(key, 1);
      };
      if ($truthy(($truthy($a = chained_keys['$empty?']()['$!']()) ? chained_keys['$[]'](0)['$=='](1) : $a))) {
        
        key = 6;
        while ($truthy(keys['$include?'](key))) {
          
          chained_keys.$unshift(key);
          key = $rb_minus(key, 1);
        };};
      return chained_keys;
    }, TMP_LostRoyal_find_sequence_from_start_key_13.$$arity = 2);
    
    Opal.defn(self, '$is_fumble?', TMP_LostRoyal_is_fumble$q_15 = function(keys, chained_sequence) {try {

      var TMP_14, self = this;

      
      $send(chained_sequence, 'each', [], (TMP_14 = function(k){var self = TMP_14.$$s || this;
if (k == null) k = nil;
      if ($truthy($rb_ge(keys.$count(k), 2))) {
          Opal.ret(true)
          } else {
          return nil
        }}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_LostRoyal_is_fumble$q_15.$$arity = 2);
    
    Opal.defn(self, '$roll_fumble_chart', TMP_LostRoyal_roll_fumble_chart_16 = function $$roll_fumble_chart() {
      var $a, $b, self = this, key = nil, text = nil;

      
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
      text = ["何かの問題で言い争い、主君に無礼を働いてしまう。あなたは主君の名誉点を１点失うか、【時間】を１点消費して和解の話し合いを持つか選べる。", "見過ごせば人々を不幸にする危険に遭遇する。あなたは逃げ出して冒険の名誉点を１点失うか、これに立ち向かい【命数】を２点減らすかを選べる。", "あなたが惹かれたのは好意に付け込む人だった。あなたはその場を去って恋慕の名誉点を１点失うか【正義】を１点減らして礼を尽くすかを選べる。", "金銭的な問題で、生命と魂の苦しみを背負う人に出会う。あなたは庇護の名誉点を１点失うか出費を３点増やすかを選べる。", "襲撃を受ける。苦もなく叩き伏せると、卑屈な態度で命乞いをしてきた。容赦なく命を奪い寛容の名誉点を１点失うか、密告によって【血路】が１Ｄ６点増えるかを選ぶことができる。", "風聞により、友が悪に身を貶めたと知る。共に並んだ戦場が色褪せる想いだ。戦友の名誉点を１点減らすか、【酒と歌】すべてを失うかを選べる。"]['$[]']($rb_minus(key, 1));
      return "" + "1D6 => [" + (key) + "] " + (text);
    }, TMP_LostRoyal_roll_fumble_chart_16.$$arity = 0);
    
    Opal.defn(self, '$roll_wind_power_chart', TMP_LostRoyal_roll_wind_power_chart_18 = function $$roll_wind_power_chart() {try {

      var TMP_17, self = this, key = nil, total_bonus = nil, text = nil;

      
      key = 0;
      total_bonus = 0;
      text = "";
      return $send(self, 'loop', [], (TMP_17 = function(){var self = TMP_17.$$s || this, $a, $b, dice = nil, add = nil, bonus = nil, current_text = nil;

      
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (dice = ($a[0] == null ? nil : $a[0])), $b;
        key = $rb_plus(key, dice);
        $b = [[true, 0, "ほぼ凪（振り足し）"], [true, 0, "弱い風（振り足し）"], [false, 0, "ゆるやかな風"], [false, 0, "ゆるやかな風"], [false, 1, "やや強い風（儀式点プラス１）"], [false, 2, "強い風（龍を幻視、儀式点プラス２）"], [false, 3, "体が揺らぐほどの風（龍を幻視、儀式点プラス３）"]]['$[]']($rb_minus([key, 7].$min(), 1)), $a = Opal.to_ary($b), (add = ($a[0] == null ? nil : $a[0])), (bonus = ($a[1] == null ? nil : $a[1])), (current_text = ($a[2] == null ? nil : $a[2])), $b;
        total_bonus = $rb_plus(total_bonus, bonus);
        if ($truthy(key['$!='](dice))) {
          current_text = "" + "1D6[" + (dice) + "]+" + ($rb_minus(key, dice)) + " " + (current_text)
          } else {
          current_text = "" + "1D6[" + (dice) + "] " + (current_text)
        };
        if ($truthy(text['$empty?']())) {
          text = current_text
          } else {
          text = "" + (text) + " => " + (current_text)
        };
        if ($truthy(add)) {
          return nil
          } else {
          
          text = $rb_plus(text, "" + " [合計：儀式点 +" + (total_bonus) + " ]");
          Opal.ret(text);
        };}, TMP_17.$$s = self, TMP_17.$$arity = 0, TMP_17));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_LostRoyal_roll_wind_power_chart_18.$$arity = 0);
    
    Opal.defn(self, '$roll_emotion_chart', TMP_LostRoyal_roll_emotion_chart_19 = function $$roll_emotion_chart() {
      var $a, $b, self = this, key = nil, text = nil;

      
      $b = self.$roll(1, 6), $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), $b;
      text = ["愛情／殺意", "友情／負目", "崇拝／嫌悪", "興味／侮蔑", "信頼／嫉妬", "守護／欲情"]['$[]']($rb_minus(key, 1));
      return "" + "1D6 => [" + (key) + "] " + (text);
    }, TMP_LostRoyal_roll_emotion_chart_19.$$arity = 0);
    
    Opal.defn(self, '$roll_hope', TMP_LostRoyal_roll_hope_21 = function $$roll_hope(number_of_dice) {try {

      var TMP_20, self = this, total = nil, text = nil;

      
      total = 0;
      text = "";
      return $send(self, 'loop', [], (TMP_20 = function(){var self = TMP_20.$$s || this, $a, $b, d1 = nil, d2 = nil;

      
        $b = self.$roll(1, 6), $a = Opal.to_ary($b), (d1 = ($a[0] == null ? nil : $a[0])), $b;
        d2 = 0;
        if ($truthy($rb_ge(number_of_dice, 2))) {
          $b = self.$roll(1, 6), $a = Opal.to_ary($b), (d2 = ($a[0] == null ? nil : $a[0])), $b};
        total = $rb_plus(total, $rb_plus(d1, d2));
        if (number_of_dice['$=='](2)) {
          text = $rb_plus(text, "" + "2D6[" + (d1) + "," + (d2) + "]")
          } else {
          text = $rb_plus(text, "" + "1D6[" + (d1) + "]")
        };
        if ($truthy(($truthy($a = self.$is_1or2(d1)) ? $a : self.$is_1or2(d2)))) {
          return (text = $rb_plus(text, " （振り足し） => "))
          } else {
          
          text = $rb_plus(text, "" + " => 合計 " + (total));
          Opal.ret(text);
        };}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, TMP_LostRoyal_roll_hope_21.$$arity = 1);
    return (Opal.defn(self, '$is_1or2', TMP_LostRoyal_is_1or2_22 = function $$is_1or2(n) {
      var $a, self = this;

      return ($truthy($a = n['$=='](1)) ? $a : n['$=='](2))
    }, TMP_LostRoyal_is_1or2_22.$$arity = 1), nil) && 'is_1or2';
  })($nesting[0], Opal.const_get_relative($nesting, 'DiceBot'), $nesting)
})(Opal);

/* Generated by Opal 0.11.4 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$exit']);
  return Opal.const_get_relative($nesting, 'Kernel').$exit()
})(Opal);
