/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$setPrefixes', '$analyzeDiceCommandResultMethod', '$gsub', '$last_match', '$torg_check', '$=~', '$debug', '$to_i', '$parren_killer', '$torg_eternity_dice', '$get_torg_eternity_bonus', '$>', '$+', '$to_s', '$!=', '$!', '$nil?', '$==', '$format', '$match', '$get_torg_eternity_modifier', '$<=', '$get_torg_eternity_damage_bonus_dice', '$<', '$get_torg_eternity_success_level', '$get_torg_eternity_damage_result', '$empty?', '$each', '$[]', '$roll', '$shift', '$&', '$-', '$get_torg_eternity_table_result', '$/']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TorgEternity');

    var $nesting = [self].concat($parent_nesting), $TorgEternity_initialize$1, $TorgEternity_rollDiceCommand$2, $TorgEternity_changeText$3, $TorgEternity_dice_command_xRn$5, $TorgEternity_torg_check$6, $TorgEternity_getRolld20DiceCommandResult$7, $TorgEternity_getUpRollDiceCommandResult$8, $TorgEternity_getPossibilityRollDiceCommandResult$9, $TorgEternity_getBonusDamageDiceCommandResult$10, $TorgEternity_getSuccessLevelDiceCommandResult$11, $TorgEternity_getDamageResultDiceCommandResult$12, $TorgEternity_getRollBonusDiceCommandResult$13, $TorgEternity_get_torg_eternity_table_result$14, $TorgEternity_get_torg_eternity_modifier$16, $TorgEternity_torg_eternity_dice$17, $TorgEternity_get_torg_eternity_damage_bonus_dice$18, $TorgEternity_get_torg_eternity_success_level$19, $TorgEternity_get_torg_eternity_damage_result$20, $TorgEternity_get_torg_eternity_bonus$21;

    
    Opal.const_set($nesting[0], 'ID', "TorgEternity");
    Opal.const_set($nesting[0], 'NAME', "TORG Eternity");
    Opal.const_set($nesting[0], 'SORT_KEY', "とおくえたあにてい");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・判定\n" + "　・TG\n" + "　　\"TG[m]\"で1d20をロールします。[]内は省略可能。\n" + "　　mは技能基本値を入れて下さい。Rコマンドに読替されます。\n" + "　　振り足しを自動で行い、20の出目が出たときには技能無し値も並記します。\n" + "　　(TORGダイスボットと同じ挙動をするコマンドです。ロールボーナスの読み替えのみ、Eternity版となります)\n" + "　・TE\n" + "　　\"TE\"で1d20をロールします。\n" + "　　振り足しを自動で行い、20の出目が出たときには技能無し値も並記します。\n" + "　　出目1の時には「Mishap!　自動失敗！」と出力されます。\n" + "　・UP\n" + "　　\"UP\"で高揚状態のロール(通常の1d20に加え、1d20を追加で振り足し)を行います。\n" + "　　各ロールでの振り足しを自動で行い、20の出目が出たときには技能無し値も並記します。\n" + "　　一投目で出目1の時には「Mishap!　自動失敗！」と出力され、二投目は行われません。\n" + "　・POS\n" + "　　\"POSm\"で、ポシビリティ使用による1d20のロールを行います。\n" + "　　mはポシビリティを使用する前のロール結果を入れて下さい。\n" + "　　出目が10未満の場合は、10への読み替えが行われます。\n" + "　　また、振り足しを自動で行い、20の出目が出たときには技能無し値も並記します。\n" + "・ボーナスダメージロール\n" + "　\"xBD[+y]\"でロールします。[]内は省略可能。\n" + "　xはダメージダイス数。yはダメージ基本値 or 式を入れて下さい。\n" + "　xは1以上が必要です。0だとエラーが出力されます。マイナス値はコマンドとして認識されません。\n" + "　振り足し処理は自動で行われます。(振り足し発生時の目は、「5∞」と出力されます)\n" + "・各種表\n" + "　\"(表コマンド)(数値)\"で振ります。\n" + "　・成功レベル表「RTx or RESULTx」\n" + "　・ダメージ結果表「DTx or DAMAGEx」\n" + "　・ロールボーナス表「BTx+y or BONUSx+y or TOTALx+y」 xは数値, yは技能基本値\n");
    self.$setPrefixes(["(TE.*|UP.*|POS.*|\\d+BD.*|TG.*|RT.*|Result.*|DT.*|damage.*|BT.*|bonus.*|total.*)"]);
    
    Opal.def(self, '$initialize', $TorgEternity_initialize$1 = function $$initialize() {
      var $iter = $TorgEternity_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $TorgEternity_initialize$1.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $TorgEternity_initialize$1, false), $zuper, $iter);
      return (self.sendMode = 2);
    }, $TorgEternity_initialize$1.$$arity = 0);
    
    Opal.def(self, '$rollDiceCommand', $TorgEternity_rollDiceCommand$2 = function $$rollDiceCommand(command) {
      var self = this;

      return self.$analyzeDiceCommandResultMethod(command)
    }, $TorgEternity_rollDiceCommand$2.$$arity = 1);
    
    Opal.def(self, '$changeText', $TorgEternity_changeText$3 = function $$changeText(string) {
      var $$4, self = this;

      
      string = $send(string, 'gsub', [/TG(\d+)/i], ($$4 = function(){var self = $$4.$$s || this;

      return "" + "1R20+" + ($$($nesting, 'Regexp').$last_match(1))}, $$4.$$s = self, $$4.$$arity = 0, $$4));
      string = string.$gsub(/TG/i, "1R20");
      return string;
    }, $TorgEternity_changeText$3.$$arity = 1);
    
    Opal.def(self, '$dice_command_xRn', $TorgEternity_dice_command_xRn$5 = function $$dice_command_xRn(string, nick_e) {
      var self = this;

      return self.$torg_check(string, nick_e)
    }, $TorgEternity_dice_command_xRn$5.$$arity = 2);
    
    Opal.def(self, '$torg_check', $TorgEternity_torg_check$6 = function $$torg_check(string, nick_e) {
      var $a, $b, self = this, output = nil, mod = nil, skilled = nil, unskilled = nil, dice_str = nil, sk_bonus = nil;

      
      output = "1";
      if ($truthy(/(^|\s)S?(1R20([+-]\d+)*)(\s|$)/i['$=~'](string))) {
      } else {
        return "1"
      };
      string = $$($nesting, 'Regexp').$last_match(2);
      mod = $$($nesting, 'Regexp').$last_match(3);
      self.$debug(mod);
      if ($truthy(mod)) {
        mod = self.$parren_killer("" + "(0" + (mod) + ")").$to_i()};
      self.$debug(mod);
      mod = mod.$to_i();
      $b = self.$torg_eternity_dice(false, false), $a = Opal.to_ary($b), (skilled = ($a[0] == null ? nil : $a[0])), (unskilled = ($a[1] == null ? nil : $a[1])), (dice_str = ($a[2] == null ? nil : $a[2])), $b;
      sk_bonus = self.$get_torg_eternity_bonus(skilled);
      if ($truthy(mod)) {
        if ($truthy($rb_gt(mod, 0))) {
          output = "" + (sk_bonus) + "[" + (dice_str) + "]+" + (mod)
        } else {
          output = "" + (sk_bonus) + "[" + (dice_str) + "]" + (mod)
        }
      } else {
        output = "" + (sk_bonus) + "[" + (dice_str) + "]"
      };
      output = $rb_plus(output, $rb_plus(" ＞ ", $rb_plus(sk_bonus, mod).$to_s()));
      if ($truthy(skilled['$!='](unskilled))) {
        output = $rb_plus(output, $rb_plus($rb_plus("(技能無", $rb_plus(self.$get_torg_eternity_bonus(unskilled), mod).$to_s()), ")"))};
      output = "" + (nick_e) + ": (" + (string) + ") ＞ " + (output);
      return output;
    }, $TorgEternity_torg_check$6.$$arity = 2);
    
    Opal.def(self, '$getRolld20DiceCommandResult', $TorgEternity_getRolld20DiceCommandResult$7 = function $$getRolld20DiceCommandResult(command) {
      var $a, $b, self = this, m = nil, secret = nil, skilled = nil, unskilled = nil, dice_str = nil, mishap = nil, output = nil, value_skilled = nil, value_unskilled = nil;

      
      self.$debug("Torg Eternity Dice Roll Command ? ", command);
      m = /(^|\s)(S)?(TE)/i['$=~'](command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      secret = $$($nesting, 'Regexp').$last_match(2)['$nil?']()['$!']();
      self.$debug("Yes!");
      $b = self.$torg_eternity_dice(false, true), $a = Opal.to_ary($b), (skilled = ($a[0] == null ? nil : $a[0])), (unskilled = ($a[1] == null ? nil : $a[1])), (dice_str = ($a[2] == null ? nil : $a[2])), (mishap = ($a[3] == null ? nil : $a[3])), $b;
      if (mishap['$=='](1)) {
        output = "" + "d20ロール（通常） ＞ 1d20[" + (dice_str) + "] ＞ Mishap!　絶対失敗！"
      } else {
        
        value_skilled = self.$format("%+d", self.$get_torg_eternity_bonus(skilled));
        if ($truthy(skilled['$!='](unskilled))) {
          
          value_unskilled = self.$format("%+d", self.$get_torg_eternity_bonus(unskilled));
          output = "" + "d20ロール（通常） ＞ 1d20[" + (dice_str) + "] ＞ " + (value_skilled) + "[" + (skilled) + "]（技能有） / " + (value_unskilled) + "[" + (unskilled) + "]（技能無）";
        } else {
          output = "" + "d20ロール（通常） ＞ 1d20[" + (dice_str) + "] ＞ " + (value_skilled) + "[" + (skilled) + "]"
        };
      };
      self.$debug(output, secret);
      return [output, secret];
    }, $TorgEternity_getRolld20DiceCommandResult$7.$$arity = 1);
    
    Opal.def(self, '$getUpRollDiceCommandResult', $TorgEternity_getUpRollDiceCommandResult$8 = function $$getUpRollDiceCommandResult(command) {
      var $a, $b, self = this, m = nil, secret = nil, skilled1 = nil, unskilled1 = nil, dice_str1 = nil, mishap = nil, output = nil, skilled2 = nil, unskilled2 = nil, dice_str2 = nil, subtotal_skilled = nil, subtotal_unskilled = nil, value_skilled = nil, value_unskilled = nil;

      
      self.$debug("Torg Eternity Dice Roll ( UP ) Command ? ", command);
      m = /(^|\s)(S)?(UP)/i['$=~'](command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      secret = $$($nesting, 'Regexp').$last_match(2)['$nil?']()['$!']();
      self.$debug("Yes!");
      $b = self.$torg_eternity_dice(false, true), $a = Opal.to_ary($b), (skilled1 = ($a[0] == null ? nil : $a[0])), (unskilled1 = ($a[1] == null ? nil : $a[1])), (dice_str1 = ($a[2] == null ? nil : $a[2])), (mishap = ($a[3] == null ? nil : $a[3])), $b;
      if (mishap['$=='](1)) {
        output = "" + "d20ロール（高揚） ＞ 1d20[" + (dice_str1) + "] ＞ Mishap!　絶対失敗！"
      } else {
        
        $b = self.$torg_eternity_dice(false, false), $a = Opal.to_ary($b), (skilled2 = ($a[0] == null ? nil : $a[0])), (unskilled2 = ($a[1] == null ? nil : $a[1])), (dice_str2 = ($a[2] == null ? nil : $a[2])), $b;
        subtotal_skilled = $rb_plus(skilled1, skilled2);
        subtotal_unskilled = $rb_plus(unskilled1, unskilled2);
        value_skilled = self.$format("%+d", self.$get_torg_eternity_bonus(subtotal_skilled));
        if ($truthy(subtotal_skilled['$!='](subtotal_unskilled))) {
          
          value_unskilled = self.$format("%+d", self.$get_torg_eternity_bonus(subtotal_unskilled));
          output = "" + "d20ロール（高揚） ＞ 1d20[" + (dice_str1) + "] + 1d20[" + (dice_str2) + "] ＞ " + (value_skilled) + "[" + (subtotal_skilled) + "]（技能有） / " + (value_unskilled) + "[" + (subtotal_unskilled) + "]（技能無）";
        } else {
          output = "" + "d20ロール（高揚） ＞ 1d20[" + (dice_str1) + "] + 1d20[" + (dice_str2) + "] ＞ " + (value_skilled) + "[" + (subtotal_skilled) + "]"
        };
      };
      self.$debug(output, secret);
      return [output, secret];
    }, $TorgEternity_getUpRollDiceCommandResult$8.$$arity = 1);
    
    Opal.def(self, '$getPossibilityRollDiceCommandResult', $TorgEternity_getPossibilityRollDiceCommandResult$9 = function $$getPossibilityRollDiceCommandResult(command) {
      var $a, $b, self = this, m = nil, secret = nil, output_modifier = nil, skilled = nil, unskilled = nil, dice_str = nil, subtotal_skilled = nil, subtotal_unskilled = nil, value_skilled = nil, value_unskilled = nil, output = nil;

      
      self.$debug("Torg Eternity Possibility Roll Command ? ", command);
      m = /(^|\s)(S)?(POS)((\d+)(\+\d+)?)/i['$=~'](command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      secret = $$($nesting, 'Regexp').$last_match(2)['$nil?']()['$!']();
      self.$debug("Yes!");
      output_modifier = self.$parren_killer("" + "(0" + ($$($nesting, 'Regexp').$last_match(4)) + ")").$to_i();
      $b = self.$torg_eternity_dice(true, false), $a = Opal.to_ary($b), (skilled = ($a[0] == null ? nil : $a[0])), (unskilled = ($a[1] == null ? nil : $a[1])), (dice_str = ($a[2] == null ? nil : $a[2])), $b;
      subtotal_skilled = $rb_plus(skilled, output_modifier);
      subtotal_unskilled = $rb_plus(unskilled, output_modifier);
      value_skilled = self.$format("%+d", self.$get_torg_eternity_bonus(subtotal_skilled));
      if ($truthy(subtotal_skilled['$!='](subtotal_unskilled))) {
        
        value_unskilled = self.$format("%+d", self.$get_torg_eternity_bonus(subtotal_unskilled));
        output = "" + "d20ロール（ポシビリティ） ＞ " + (output_modifier) + "+1d20[" + (dice_str) + "] ＞ " + (value_skilled) + "[" + (subtotal_skilled) + "]（技能有） / " + (value_unskilled) + "[" + (subtotal_unskilled) + "]（技能無）";
      } else {
        output = "" + "d20ロール（ポシビリティ） ＞ " + (output_modifier) + "+1d20[" + (dice_str) + "] ＞ " + (value_skilled) + "[" + (subtotal_skilled) + "]"
      };
      self.$debug(output, secret);
      return [output, secret];
    }, $TorgEternity_getPossibilityRollDiceCommandResult$9.$$arity = 1);
    
    Opal.def(self, '$getBonusDamageDiceCommandResult', $TorgEternity_getBonusDamageDiceCommandResult$10 = function $$getBonusDamageDiceCommandResult(command) {
      var $a, $b, self = this, m = nil, number_bonus_die = nil, value_modifier = nil, output_modifier = nil, output = nil, value_roll = nil, output_roll = nil, output_value = nil;

      
      self.$debug("TorgEternity Bonus Damage Roll Command ? ", command);
      m = /(\d+)(BD)(([\+\-]\d+)*)/i.$match(command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      self.$debug("Yes!");
      number_bonus_die = $$($nesting, 'Regexp').$last_match(1).$to_i();
      $b = self.$get_torg_eternity_modifier($$($nesting, 'Regexp').$last_match(3)), $a = Opal.to_ary($b), (value_modifier = ($a[0] == null ? nil : $a[0])), (output_modifier = ($a[1] == null ? nil : $a[1])), $b;
      if ($truthy($rb_le(number_bonus_die, 0))) {
        output = "エラーです。xBD (x≧1) として下さい"
      } else {
        
        $b = self.$get_torg_eternity_damage_bonus_dice(number_bonus_die), $a = Opal.to_ary($b), (value_roll = ($a[0] == null ? nil : $a[0])), (output_roll = ($a[1] == null ? nil : $a[1])), $b;
        output_value = $rb_plus(value_roll, value_modifier);
        output = "" + "ボーナスダメージロール(" + (number_bonus_die) + "BD" + (output_modifier) + ") ＞ " + (value_roll) + "[" + (output_roll) + "]" + (output_modifier) + " ＞ " + (output_value) + "ダメージ";
      };
      return output;
    }, $TorgEternity_getBonusDamageDiceCommandResult$10.$$arity = 1);
    
    Opal.def(self, '$getSuccessLevelDiceCommandResult', $TorgEternity_getSuccessLevelDiceCommandResult$11 = function $$getSuccessLevelDiceCommandResult(command) {
      var self = this, m = nil, value = nil, output = nil;

      
      self.$debug("TorgEternity Success Level Table Command ? ", command);
      m = /(RT|Result)(\d+([\+\-]\d+)*)/i.$match(command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      self.$debug("Yes!");
      value = self.$parren_killer("" + "(0" + ($$($nesting, 'Regexp').$last_match(2)) + ")").$to_i();
      self.$debug(value);
      if ($truthy($rb_lt(value, 0))) {
        output = "Failure."
      } else {
        output = self.$get_torg_eternity_success_level(value)
      };
      output = "" + "成功レベル表[" + (value) + "] ＞ " + (output);
      self.$debug(output);
      return output;
    }, $TorgEternity_getSuccessLevelDiceCommandResult$11.$$arity = 1);
    
    Opal.def(self, '$getDamageResultDiceCommandResult', $TorgEternity_getDamageResultDiceCommandResult$12 = function $$getDamageResultDiceCommandResult(command) {
      var self = this, m = nil, value = nil, output = nil;

      
      self.$debug("TorgEternity Damage Result Table Command ? ", command);
      m = /(DT|Damage)(\d+([\+\-]\d+)*)/i.$match(command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      self.$debug("Yes!");
      value = self.$parren_killer("" + "(0" + ($$($nesting, 'Regexp').$last_match(2)) + ")").$to_i();
      self.$debug(value);
      output = self.$get_torg_eternity_damage_result(value);
      output = "" + "ダメージ結果表[" + (value) + "] ＞ " + (output);
      self.$debug(output);
      return output;
    }, $TorgEternity_getDamageResultDiceCommandResult$12.$$arity = 1);
    
    Opal.def(self, '$getRollBonusDiceCommandResult', $TorgEternity_getRollBonusDiceCommandResult$13 = function $$getRollBonusDiceCommandResult(command) {
      var $a, $b, self = this, m = nil, value_roll = nil, output_bonus = nil, value_modifier = nil, output_modifier = nil, output = nil, value_result = nil;

      
      self.$debug("TorgEternity Roll Bonus Table Command ? ", command);
      m = /(BT|Bonus)(\d+)(([\+\-]\d+)*)/i.$match(command);
      if ($truthy(m)) {
      } else {
        
        self.$debug("None");
        return nil;
      };
      self.$debug("Yes!");
      value_roll = $$($nesting, 'Regexp').$last_match(2).$to_i();
      output_bonus = self.$get_torg_eternity_bonus(value_roll);
      self.$debug(output_bonus);
      $b = self.$get_torg_eternity_modifier($$($nesting, 'Regexp').$last_match(3)), $a = Opal.to_ary($b), (value_modifier = ($a[0] == null ? nil : $a[0])), (output_modifier = ($a[1] == null ? nil : $a[1])), $b;
      if ($truthy($rb_le(value_roll, 1))) {
        output = "" + "ロールボーナス表[" + (value_roll) + "] ＞ Mishap!!"
      } else if ($truthy(output_modifier['$empty?']())) {
        output = "" + "ロールボーナス表[" + (value_roll) + "] ＞ " + (output_bonus)
      } else {
        
        value_result = $rb_plus(output_bonus.$to_i(), value_modifier);
        self.$debug(value_result);
        output = "" + "ロールボーナス表[" + (value_roll) + "]" + (output_modifier) + " ＞ " + (output_bonus) + "[" + (value_roll) + "]" + (output_modifier) + " ＞ " + (value_result);
      };
      self.$debug(output);
      return output;
    }, $TorgEternity_getRollBonusDiceCommandResult$13.$$arity = 1);
    
    Opal.def(self, '$get_torg_eternity_table_result', $TorgEternity_get_torg_eternity_table_result$14 = function $$get_torg_eternity_table_result(value, table) {
      var $$15, self = this, output = nil;

      
      output = nil;
      (function(){var $brk = Opal.new_brk(); try {return $send(table, 'each', [], ($$15 = function(item){var self = $$15.$$s || this, item_index = nil;

      
        
        if (item == null) {
          item = nil;
        };
        item_index = item['$[]'](0);
        if ($truthy($rb_gt(item_index, value))) {
          
          Opal.brk(nil, $brk)};
        return (output = item['$[]'](1));}, $$15.$$s = self, $$15.$$brk = $brk, $$15.$$arity = 1, $$15))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return output;
    }, $TorgEternity_get_torg_eternity_table_result$14.$$arity = 2);
    
    Opal.def(self, '$get_torg_eternity_modifier', $TorgEternity_get_torg_eternity_modifier$16 = function $$get_torg_eternity_modifier(string_modifier) {
      var self = this, value_modifier = nil, output_modifier = nil;

      
      self.$debug("" + "modifier check : " + (string_modifier));
      if (string_modifier['$==']("")) {
        
        value_modifier = 0;
        output_modifier = "";
      } else {
        
        value_modifier = self.$parren_killer("" + "(0" + (string_modifier) + ")").$to_i();
        output_modifier = self.$format("%+d", value_modifier);
      };
      self.$debug(value_modifier);
      self.$debug(output_modifier);
      return [value_modifier, output_modifier];
    }, $TorgEternity_get_torg_eternity_modifier$16.$$arity = 1);
    
    Opal.def(self, '$torg_eternity_dice', $TorgEternity_torg_eternity_dice$17 = function $$torg_eternity_dice(check_pos, check_mishap) {
      var $a, self = this, isSkilledCritical = nil, isCritical = nil, skilled = nil, unskilled = nil, mishap = nil, dice_str = nil, dummy = nil, dice_n = nil, dice_str_now = nil;

      
      isSkilledCritical = true;
      isCritical = true;
      skilled = 0;
      unskilled = 0;
      mishap = 0;
      dice_str = "";
      while ($truthy(isSkilledCritical)) {
        
        if ($truthy(dice_str['$empty?']())) {
        } else {
          dice_str = $rb_plus(dice_str, ",")
        };
        dummy = self.$roll(1, 20, 0);
        dice_n = dummy.$shift();
        if ($truthy(check_pos)) {
          
          if ($truthy($rb_lt(dice_n, 10))) {
            
            dice_str_now = "" + (dice_n) + "→10";
            dice_n = 10;
            isSkilledCritical = false;
          } else {
            dice_str_now = dice_n.$to_s()
          };
          dice_str = $rb_plus(dice_str, dice_str_now);
        } else {
          dice_str = $rb_plus(dice_str, dice_n.$to_s())
        };
        skilled = $rb_plus(skilled, dice_n);
        if ($truthy(isCritical)) {
          unskilled = $rb_plus(unskilled, dice_n)};
        if (dice_n['$=='](20)) {
          isCritical = false
        } else if ($truthy(dice_n['$!='](10))) {
          
          isSkilledCritical = false;
          isCritical = false;
          if ($truthy(check_mishap['$&'](dice_n['$=='](1)))) {
            mishap = 1};};
        check_pos = false;
        check_mishap = false;
      };
      return [skilled, unskilled, dice_str, mishap];
    }, $TorgEternity_torg_eternity_dice$17.$$arity = 2);
    
    Opal.def(self, '$get_torg_eternity_damage_bonus_dice', $TorgEternity_get_torg_eternity_damage_bonus_dice$18 = function $$get_torg_eternity_damage_bonus_dice(number) {
      var $a, $b, $c, self = this, value_roll = nil, output_roll = nil, dice_value = nil, dice_text = nil;

      
      self.$debug("" + "bonus dice roll : " + (number));
      value_roll = 0;
      output_roll = "";
      if ($truthy($rb_gt(number, 0))) {
        
        value_roll = 0;
        output_roll = "";
        while ($truthy($rb_gt(number, 0))) {
          
          if ($truthy(output_roll['$empty?']())) {
          } else {
            output_roll = "" + (output_roll) + ","
          };
          $c = self.$roll(1, 6), $b = Opal.to_ary($c), (dice_value = ($b[0] == null ? nil : $b[0])), (dice_text = ($b[1] == null ? nil : $b[1])), $c;
          if (dice_value['$=='](6)) {
            
            dice_value = 5;
            dice_text = "5∞";
            number = $rb_plus(number, 1);};
          value_roll = $rb_plus(value_roll, dice_value);
          output_roll = "" + (output_roll) + (dice_text);
          self.$debug(value_roll);
          self.$debug(output_roll);
          number = $rb_minus(number, 1);
        };
      } else {
        output_roll = "0"
      };
      self.$debug(value_roll);
      self.$debug(output_roll);
      return [value_roll, output_roll];
    }, $TorgEternity_get_torg_eternity_damage_bonus_dice$18.$$arity = 1);
    
    Opal.def(self, '$get_torg_eternity_success_level', $TorgEternity_get_torg_eternity_success_level$19 = function $$get_torg_eternity_success_level(value) {
      var self = this, success_table = nil;

      
      success_table = [[0, "Success - Standard."], [5, "Success - Good!"], [10, "Success - Outstanding!!"]];
      return self.$get_torg_eternity_table_result(value, success_table);
    }, $TorgEternity_get_torg_eternity_success_level$19.$$arity = 1);
    
    Opal.def(self, '$get_torg_eternity_damage_result', $TorgEternity_get_torg_eternity_damage_result$20 = function $$get_torg_eternity_damage_result(value) {
      var self = this, damage_table = nil;

      
      damage_table = [[-50, "ノーダメージ"], [-5, "1ショック"], [0, "2ショック"], [5, "1レベル負傷 + 2ショック"], [10, "2レベル負傷 + 4ショック"], [15, "3レベル負傷 + 6ショック"], [20, "4レベル負傷 + 8ショック"], [25, "5レベル負傷 + 10ショック"], [30, "6レベル負傷 + 12ショック"], [35, "7レベル負傷 + 14ショック"], [40, "8レベル負傷 + 16ショック"], [45, "9レベル負傷 + 18ショック"], [50, "10レベル負傷 + 20ショック"]];
      return self.$get_torg_eternity_table_result(value, damage_table);
    }, $TorgEternity_get_torg_eternity_damage_result$20.$$arity = 1);
    return (Opal.def(self, '$get_torg_eternity_bonus', $TorgEternity_get_torg_eternity_bonus$21 = function $$get_torg_eternity_bonus(value) {
      var self = this, bonus_table = nil, bonus = nil, over_value_bonus = nil;

      
      bonus_table = [[1, -10], [2, -8], [3, -6], [5, -4], [7, -2], [9, -1], [11, 0], [13, 1], [15, 2], [16, 3], [17, 4], [18, 5], [19, 6], [20, 7]];
      bonus = self.$get_torg_eternity_table_result(value, bonus_table);
      if ($truthy($rb_gt(value, 20))) {
        
        over_value_bonus = $rb_plus($rb_divide($rb_minus(value, 21), 5).$to_i(), 1);
        bonus = $rb_plus(bonus, over_value_bonus);};
      return bonus;
    }, $TorgEternity_get_torg_eternity_bonus$21.$$arity = 1), nil) && 'get_torg_eternity_bonus';
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting)
})(Opal);
